\documentclass[brudnopis]{xmgr}

\usepackage{listings}
% "define" Scala
\lstdefinelanguage{scala}{morekeywords={class,object,trait,extends,with,new,if,while,for,def,val,var,this},
otherkeywords={->,=>},
sensitive=true,
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morestring=[b]"}
% Default settings for code listings
\lstset{frame=tb,language=scala,aboveskip=3mm,belowskip=3mm,showstringspaces=false,columns=flexible,basicstyle={\small\ttfamily}}


%\defaultfontfeatures{Scale=MatchLowercase}
%\setmainfont[Numbers=OldStyle,Ligatures=TeX]{Minion Pro}
%\setsansfont[Numbers=OldStyle,Ligatures=TeX]{Myriad Pro}
% for fontspec version < 2.0
\setmainfont[Numbers=OldStyle,Mapping=tex-text]{Minion Pro}
\setsansfont[Numbers=OldStyle,Mapping=tex-text]{Myriad Pro}
%\setmonofont[Scale=0.75]{Monaco}

% Opcjonalnie identyfikator dokumentu 
% drukowany tylko z włączoną opcją 'brudnopis':
\wersja   {wersja wstępna [\ymdtoday]}

\author   {Mateusz Szygenda}
\nralbumu {186\,436}
\email    {mateusz.szygenda@gmail.com}

\title    {Wykorzystanie baz grafowych w języku Scala}
\date     {2014}
\miejsce  {Gdańsk}

\opiekun  {dr Wiesław Pawłowski}

% dodatkowe polecenia
%\renewcommand{\filename}[1]{\texttt{#1}}

\begin{document}

\begin{abstract}
Wstęp
\end{abstract}
\keywords{Scala, neo4j, DSL, języki domenowe, bazy grafowe}

% tytuł i spis treści
\maketitle

%
% wstęp
\introduction

W ostatnich latach można było zaobserwować pojawienie się wielu baz danych zrywających paradygmatem baz relacyjnych które przodowały przez wiele lat. Mowa tutaj o bazach dokumentowych takich jak MongoDB, Redis czy baz grafowych (neo4j). W określonych warunkach oferują one dużo większą wydajność niż bazy relacyjne. Oczywiście odbywa się to pewnym kosztem. W przypadku baz dokumentowych jest to zerwanie z normalizacją oraz transakcyjnością lub z całkowitą zmianą paradygmatu jak ma to miejsce w przypadku baz grafowych. Poszukiwanie wydajniejszych rozwiązań do składowania danych ma oczywiście swoją przyczynę. Jest to mianowicie fakt iż współczesne aplikacje internetowe muszą obsługiwać miliony użytkowników w czasie rzeczywistym. Baza danych która jest niejednokrotnie głównym elementem układanki musi oczwyiście sprostać tym wymaganiom. Okazuje się jednak, że w przypadku danych w których rekordy są ze sobą ściśle powiązane relacjami bazy relacyjne mogą okazać się niewystarczające. Wynika to ze sposobu w jaki relacje są realizowane w takich bazach. Wykorzystywany mianowicie jest mechanizm kluczy obcych, natomiast na poziomie zapytań bazodanowych wykonywany jest iloczyn kartezjański co przy dużej ilości danych i kilku relacjach zajmuje olbrzymią ilość czasu. Z punktu widzenia użytkownika jest całkowicie nie do zaakceptowania by obsłużenie jego żądania zajmowało czas rzędu kilkunastu sekund lub nawet minut (ODNOŚNIK DO PORÓWNANIA WYDAJNOŚCIOWEGO). Potrzeba zatem wydajnego mechanizmu który byłby w stanie spełnić rygorystyczne wymogi wydajnościowe oraz dobrze radzi sobie z danymi powiązanymi wieloma relacjami. Odpowiedzią są bazy grafowe które stosują reprezentację grafów do zapisywania rekordów. Jak zostanie to wyjaśnione  w dalszych rozdziałach ma to znaczący wpływ na wydajność i sposób operowania na danych. Celem pracy było stworzenie narzędzia dla języka Scala pozwalającego na efektywne wykorzystanie jednej z opisywanych baz grafowych. Język ten został wybrany ze względu na dostępność licznych mechanizmów ułatwiających definiowanie tzw. języków domenowych (DSL). 

\chapter{Bazy grafowe}

\section{Wstęp}

Zgodnie z teorią grafów (ODNOŚNIK DO KSIĄŻKI), graf to struktura składająca się ze zbioru wierzchołków oraz zbioru krawędzi który może być reprezentowany przez zbiór zbiorów. W tym przypadku mamy do czynienia z krawędziami nieskierowanymi. Zbiór krawędzi może być również reprezentowany jako zbiór par wierzchołków, wtedy są to krawędzie skierowane. Bazy grafowe wykorzystują właśnię tę strukturę reprezentowania wszystkich danych rozszerzając ją tylko w nieznaczny sposób (np. dodając pojęcie nazwanych krawędzi). Pomimo faktu iż teoria grafów jest dziedziną niemłodą i znaną od dłuższego czasu to same bazy grafowe są stosunkowo świeżym tworem. Jak wspomina autor bazy Neo4j, w roku 1999 nie istniała praktycznie żadna baza grafowa mogąca być wykorzystana w sposób produkcyjny (ODNOŚNIK DO KSIĄŻKI). Sposób w jaki sposób bazy grafowe prezentują dane implikuje odmienny sposób przeszukiwania i operowania na zbiorze danych. Nie istnieje tutaj pojęcie tabeli znane z baz relacyjnych takich jak MySQL która narzucała by określoną strukturę dla naszych danych. Zamiast tego mamy tu do czynienia z węzłami które mogą zawierać dowolną ilość prostych pól. Pod tym względem przypominają one bazy dokumentowe w których również nie ma narzuconej struktury. W odróżnieniu jednak zarówno od baz relacyjnych jak i dokumentowych relacje między obiektami są zapisywane tutaj za pomocą nazwanych i skierowanych krawędzi. Pojedyńczy węzeł może mieć dowolnie wiele różnych krawędzi wychodzących jak i wchodząch (W dalszej części pracy będziemy używać zamiennie terminu krawędzi i relacji). Przeszukiwanie baz grafowych odbywa się poprzez definiowanie interesujących wzorców w grafie. Dzięki efektywnym algorytmom przeszukiwania grafów taki sposób przechowywania danych ma znaczący wpływ na wydajność.

Oto przykład ukazujący porównanie wydajności bazy grafowej i bazy MySQL dla analogicznej struktury danych i zapytań skupionych w okół relacji.

WYKRES Z MODELEM I ZAPYTANIEM SQL (Pożyczony z książki o neo4j)

WYKRES Z MODELEM I ZAPYTANIEM CYPHER (Pożyczony z książki o neo4j)

WYKRESY Z WYDAJNOŚCIĄ (Pożyczony z książki o neo4j)

Znacząca przewaga neo4j wynika tutaj przede wszystkim z lokalności operacji wykonywanych na naszych danych (tj. nie musimy przeszukiwać wszystkich węzłów a jedynie te które są fizycznie połączone z interesującymi nas węzłami) w przeciwieństwie do bazy MySQL w której z każdą relacją musimy wykonać iloczyn kartezjański który wymaga przejrzenia całego zbioru danych.

\section{Rodzaje baz grafowych}

\subsection{Bazy z relacyjnym magazynem danych}

Rozróżniamy dwa główne rodzaje baz grafowych. Pierwszym z nich są bazy które pozwalają operować na przechowywanych danych jak na grafach, mających jednak odmienny sposób składowania danych. Popularnym rozwiązaniem jest np. przechowywanie struktury grafowej w bazach relacyjnych. Niestety takie rozwiązanie nie pozwala na pełne wykorzystanie potencjału drzemiącego w przechowywaniu danych w postaci grafów. Przykładem takiej bazy jest FlockDB która znajduje zastosowanie w popularnym serwisie społecznościowym Twitter. Ze względu na potencjalne problemy wydajnościowe bazy tego typu nie będą omawiane w tej pracy.

\subsection{Bazy natywne}
Drugim rodzajem baz grafowych są natywne bazy grafowe które nie tylko przedstawiają dane w formie grafów ale również wykorzystują strukturę grafów do ich składowania. Ma to tę zaletę iż przeszukiwanie takiej bazy może okazać się o wiele wydajniejsze niż odpowiednik przechowywany w bazie relacyjnej. Powodem tego jest lokalność operacji wykonywanych na grafie. W odróżnieniu do baz relacyjnych gdzie by wyszukać dane powiązane pewną relacją wymagane jest wykonanie iloczynu kartezjańskiego na całych zbiorach danych. W przypadku ogromnej liczby rekordów taka operacja może okazać się wielce niewydajna. W przypadku baz grafowych nie ma potrzeby odwiedzania wszystkich danych bowiem poruszamy się tylko w obrębie obiektów w bezpośredni sposób związanych ze sobą krawędziami. Przykładem takiej bazy jest np. Neo4J której została poświęcona znaczna część tej pracy.

\section{Wiodące bazy}

\chapter{Neo4j}

Neo4j jest natywną bazą grafową napisaną w języku Java. 

\section{Język Cypher}
Cypher jest językiem zapytań stworzonym specjalnie na potrzeby neo4j pozwalającym w sposób deklaratywny przeszukiwać bazę grafową.

\subsection{Przeszukiwanie grafu}

Najważniejszym rodzajem zapytań jest oczywiście zapytanie służące do wyszukiwania wzorców i wyciągania danych z grafu. Zapytanie takie składa się z trzech podstawowych części.

Sekcja "START" pozwala na wyciągnięcie węzłów startowych od których zacznie się przeszukiwanie grafu. Węzły można wyciągnąć na podstawie jego wewnętrznego identyfiaktora lub z wykorzystaniem przygotowanego wcześniej indeksu. Sekcja ta jest opcjonalna jednak jest wysoce wskazane by określać węzły startowe. Bez tego zapytanie traci zaletę lokalności gdyż do później zdefiniowanego wzorca będzie dopasowany każdy węzeł znajdujący się w bazie danych.

\lstinputlisting{listings/cypher/start-section.cypher}

Sekcja "MATCH" jest główną częścią zapytania, pozwala ona bowiem określić interesujące nas wzorce w grafie. Część ta jest swego rodzaju odpowiednikiem instrukcji INNER JOIN w języku SQL gdyż pozwala nam określić relacje pomiędzy węzłami początkowymi.

\lstinputlisting{listings/cypher/match-section.cypher}

Ostatnim elementem zapytania jest sekcja "RETURN" pozwalająca zdefiniowanie obcięcia które ma zostać zwrócone jako wynik zapytania.

\lstinputlisting{listings/cypher/return-section.cypher}

Pełne zapytanie wygląda następująco i zwraca ono identyfikatory oraz imona obiektów które są połączone krawędzią o identyfikatorze "KNOWS" z obiektem john oraz będące połączone krawędzią "LIKES" z obiektem o identyfikatorze równym 1. Poruszając się w domenie sieci społecznościowej zapytanie zwraca znajomych użytkownika John którzy polubili komentarz o identyfikatorze 1.

\lstinputlisting{listings/cypher/sample-query.cypher}

\subsection{Modyfikacja danych}

Język Cypher pozwala również na aktualizację danych w grafie. Wyrażenie takie podobnie jak zapytanie służące do wyszukiwania w grafie składa się z kilku sekcji.

Pierwszą z nich ponownie jest sekcja "START" która pozwala na wybranie wezłów początkowych między którymi będziemy wstawiać relacje. Jest ona opcjonalna jeśli zamierzamy operować wyłącznie na nowych obiektach.

\lstinputlisting{listings/cypher/start-section.cypher}

Kolejną sekcją jest "CREATE" której składnia jest podobna do sekcji "MATCH". W przeciwieństwie jednak do MATCH pozwala ona na tworzenie krawędzi w grafie oraz węzłów.

\lstinputlisting{listings/cypher/create-section.cypher}

Ostatnim elementem jest wykorzystana już wcześniej sekcja RETURN która pozwala na wyciągnięcie danych o nowoutworzonych obiektach takich jak ich identyfikatory.

\lstinputlisting{listings/cypher/return-section-2.cypher}

Pełne zapytanie wstawiające do grafu nowy obiekt o polu "name" równym "New Friend" i łączące go z obiektami "john" oraz "comment" wygląda następująco

\lstinputlisting{listings/cypher/sample-create-query.cypher}

\section{Programistyczne sposoby dostępu do neo4j}

\subsection{Embedded mode}

\subsection{REST mode}

\subsection{Zapytania Cypher}

\chapter{Język Scala}

Języki takie jak Java, C\# czy C++ są obiektowymi językami programowania opartymi na paradygmacie programowania imperatywnego. Zakłada on istnienie stanu w programie który podlega ciągłej zmianie. Przeciwieństwem tego podejścia jest programowanie funkcyjne w którym funkcje programu nie posiadają efektów ubocznych i bardziej przypominają funkcje znane z matematyki. Scala jest językiem łączącym paradygmat imperatywnego programowania obiektowego i programowania funkcyjnego.

\subsection{Programowanie funkcyjne}

\subsection{Podstawy składni}
Łatwość definiowania DSL itd.

\subsection{Pattern Matching}

\chapter{Dostęp do baz danych z wykorzystaniem DSL}

Wszystkie bazy danych udostępniają pewien natywny interfejs do manipulacji na przechowywanych rekordach. W przypadku baz relacyjnych mamy do dyspozycji język SQL. O ile np. sam język SQL jest prostym w użyciu narzędziem to rzadko kiedy z poziomu tworzonego programu chcemy operować bezpośrednio na nim. Potrzebna jest pewna warstwa abstrakcji która ukryje przed programistą pewne różnice w implementacji SQLa w różnych bazach relacyjnych jak i uchroni ich przed typowymi błędami programistycznymi takimi jak SQL Injection. Rozwiązaniem tego problemu są tzw. mappery bazodanowe takie jak Hibernate. Udostępniają one mechanizmy które pozwalają na zdefiniowanie powiązania pomiędzy klasami programu a tabelami/kolekcjami w bazie danych. Narzędzia te zajmują się tłumaczeniem wywołań odpowiednich metod na zapytania języka obsługiwanego przez daną bazę. Oprócz tego zamiast zwracania generycznych obiektów z wynikami zapytań, zamieniane są one na instancje klas które reprezentują poszczególne rekordy.

Alternatywą dla klasycznych rozwiązań typu Hibernate są tzw. DSLe bazodanowe czyli języki domenowe pozwalające w pewnym uproszczeniu na zapisywanie zapytań danego języka bazodanowego wprost w kodzie programu. Tak budowane zapytania są zwykłymi wywołaniami metod danego języka stąd są automatycznie walidowane na etapie kompilacji.

Rozdział ten ma na celu przedstawienie istniejących rozwiązań dla baz relacyjnych jak i NoSQL będącymi inspiracją dla tworzonego narzędzia.

\section{Bazy SQL}

\subsection{Squeryl}

Sztandarowym przykładem DSLa bazodanowego dla języka Scala jest projekt Squeryl. Umożliwia on zdefiniowanie struktury bazy danych w kodzie programu a następnie budowania zapytań z wykorzystaniem zdefiniowanej wcześniej struktury.

Pierwszym etapem w przypadku narzędzia Squeryl jest stworzenie odwzorowania struktury bazy danych. Definiuje się ją z wykorzystaniem zwykłych klas języka scala oraz specjalnej klasy Schema. Przykładowa struktura (przykład z dokumentacji Squeryla)

\lstinputlisting{listings/scala/squeryl-schema.scala}

Po zdefiniowaniu struktury możliwe jest budowanie zapytań bazodanowych. Oto przykładowe zapytanie 

\lstinputlisting{listings/scala/squeryl-query.scala}

\section{Bazy NoSQL}

\subsection{Mongoid}

\chapter{DSL do baz grafowych}

Bazy grafowe w sposób znaczący różnią się w sposobie dostępu do danych. Główną osią zapytań w przypadku baz grafowych są wzorce stąd narzędzie powinno umożliwiać na budowanie wzorców dowolnej długości. Podobnie jak w bibliotece Squeryl w stworzonym narzędziu przed tworzeniem jakichkolwiek zapytań trzeba zdefiniować strukturę bazy danych. Inaczej jednak niż w przypadku squeryla definiowanie struktury odbywa się wyłącznie na poziomie klas domenowych. Nie ma potrzeby tworzenia jednego specjalnego obiektu skupiającego w sobie wszystkie powiązania. Dzięki określonej strukturze możliwe jest budowanie silnie typowanych wzorców i całych zapytań. Jest to niewątpliwą zaletą w stosunku do ręcznego pisania zapytań języka Cypher. Oczywiście wszystko będzie odpowiadało strukturze naszej bazy pod warunkiem, że model został poprawnie zdefiniowany. Przypomnijmy, że w bazach takich jak Neo4j nie istnieje pojęcie schematu i nie ma z góry określonej struktury. To programista lub narzędzie do obsługi bazy musi zapewnić spójność w tym aspekcie.

\section{Definiowanie modelu}

Pierwszym krokiem jaki należy wykonać przed definiowaniem zapytań jest utworzenie modelu (tj. zbioru klas) odpowiadającemu dziedzinie którą przechowujemy w bazie grafowej. Stworzone narzędzie udostępnia mechanizmy pomocnicze które pozwalają na szybkie odwzorowanie encji oraz relacji między nimi.

\subsection{Klasa DomainObject}

Wszystkie klasy domenowe muszą dziedziczyć po generycznej klasie DomainObject która dostarcza narzędziu niezbędnych informacji do działania. Jest to klasa generyczna która wymaga określenia typu klasy którą definiujemy. Informacja ta jest potrzebna w celu nakładania ograniczeń na obiekty które będzie można stosować do poszczególnych relacji.

Definiowana klasa może zawierać pola następujących typów: Int, Byte, Short, Char, Long, Double, Float, String.

\subsection{Relacje}

Oczywiście najistotniejszą informacją w przypadku baz grafowych są relacje czy też krawędzie wychodzące z węzłów danego typu. Należy je zdefiniować jako pola w klasie domenowej. Nie ma oczywiście potrzeby tworzenia obiektów w sposób ręczny gdyż klasa DomainObject udostępnia metody pomocnicze pozwalające na definiowanie relacji. Są to metody  -->, <--, -- które jednocześnie określają kierunek. Metody te są generyczne i pozwalają na określenie typu obiektów pomiędzy którymi zachodzić będzie relacja. Przyjmują one jeden parametr typu String który pozwala na zdefiniowanie nazwy relacji czy też krawędzi.

\subsection{Przykładowy model}

Oto przykładowa klasa domenowa reprezentująca osobę. Zawiera ona pola takie jak name, surname odpowiadające imieniu i nazwisku osoby oraz pola definiujące krawędzie wchodzące i wychodzące z węzłów tego typu. Są to relacje knows która definiuje krawędź wychodzącą do obiektów typu Person oraz wrote która jest relacją skierowaną do naszego obiektu i jest powiązana z obiektem typu Comment.

\lstinputlisting{listings/scala/dsl/sample-model.scala}

\section{Budowanie wzorców}

Zapytania w bazach grafowych skupiają się na wyszukiwaniu określonych wzorców. Z tego powodu główny nacisk w obrębie ekspresywności tworzonego DSLa został położony właśnie na tej części.

Do budowania wzorców wykorzystywana jest klasa PatternBuilder której instancje tworzone są przez metody pomocnicze używane przy definiowaniu klas, są to mianowicie omówione wcześniej metody <--, --, -->. Klasa PatternBuilder definiuje metodę apply której argumentem może być pojedyńczy obiekt typu określonego w wywołaniu metody kierunkowej lub cały wzorzec który zaczyna się od węzła tego typu. Implikuje to iż budowane wzorce będą zawsze podlegać regułom typów określonym klasach domenowych. Niemożliwe jest na przykład utworzenie wzorca person -[:KNOWS]-> comment gdyż zachodzi niezgodność typów (comment nie jest typu Person).

Oto przykładowe złożenie kilku wzorców. Obiekty john, friend, matthew są typu Person podczas gdy wiseComment jest obiektem typu Comment.

\lstinputlisting{listings/scala/dsl/patterns/functional-example-1.scala}

Wynikiem pojedyńczego wyrażenia budującego wzorzec jest obiekt typu Pattern którego najbardziej istotną podklasą jest PatternTriple. Jest to generyczna klasa która składa się z trzech elementów. Pierwszym z nich jest początek wzorca czyli pojedyńczy węzeł od którego zaczyna się wzorzec. Kolejnym elementem jest relacja z określonym kierunkiem która określa jakiego typu obiektu spodziewamy się w dalszej części wzorca. Ostatnim elementem jest obiekt typu PatternWithNode który jest superklasą bardziej specyficznych PatternNode który służy do definiowania pojedyńczych węzłów oraz wspomniana już klasa PatternTriple. PatternTriple pozwala zatem na definiowanie rekurencyjnej struktury wzorca.

\section{Nakładanie warunków na wyniki zapytań}

Jednym z bardziej istotnych mechanizmów przy przeszukiwaniu baz danych jest możliwość nakładania warunków na zwracane wyniki. Założeniem projektu było aby nie było potrzeby wprowadzania nowej składni do budowania wyrażeń typu Boolean innej niż ta dostarczana przez sam język scala. Oczywiście wyrażenia powinny być wykonywane po stronie serwera bazy stąd zwykłe wyrażenia typu boolean które ewaluuje się do prawdy lub fałszu byłyby niewystarczające by można je przenieść do zapytania Cypher. Aby wyciągnąć strukturę wyrażenia logicznego potrzebne jest wykorzystanie mechanizmu makr które pozwala na modyfikacje abstrakcyjnego drzewa składniowego.

\subsection{Makra}

Makra są eksperymentalną funkcjonalnością języka scala wprowadzone w wersji WERSJA. Są one podobnie jak w przypadku makr znanych z języka C wykonywane podczas etapu kompilacji jednak dają o wiele więcej możliwości. Najważniejszą różnicą w stosunku do wspomnianego C jest fakt, że makra języka Scala nie definiują żadnego specyficznego do tego typu zadań mini-języka. Zamiast tego makra mogą być pisane w języku Scala. Co więcej nie ograniczają się one do prostej zamiany tekstu w kodzie programu jak to bywa w przypadku innych języków ale pozwalają na modyfikację drzewa składniowego. Oczywiście jest to dużo bardziej zaawansowany mechanizm i jego właściwe wykorzystanie jest bardziej skomplikowane, niemniej w zamian otrzymujemy bardzo potężny mechanizm.

By zdefiniować makro w kodzie programu należy utworzyć obiekt z metodą która zamiast ciała zawiera słowo kluczowe macro oraz nazwę metody implementującej dane makro.
Metoda implementująca makro powinna mieć dwie listy parametrów. Pierwsza z nich powinna składać się z argumentu typu Context. Druga lista parametrów powinna zawierać tak samo nazwane argumenty jak w przypadku deklaracji makra jednak ich typ powinien być opakowany przez klasę Expr zdefiniowaną w obiekcie Context. Typem zwracanym takiej metody jest obiekt typu Expr zdefiniowany w kontekście obiektu Context.

Oto przykładowa definicja makra

\lstinputlisting{listings/scala/macro-sample.scala}

Wszystkie wywołania metody assert zostaną zamienione podczas procesu kompilacji przez wyrażenie wygenerowane przez metodę assertImpl. 

Obiekt typu Expr zawiera w sobie strukturę wyrażenia ktore reprezentuje. W przypadku parametrów zawiera on drzewo składniowe przed dokonaniem ewaluacji. Dlatego przy wywołaniu metody assert z parametrami (someInt == 5, "someInt is equal to 5"), w metodzie implementującej mamy dostęp do struktury wyrażenia someInt == 5 które możemy dowolnie przetransformować.

\subsection{Przetwarzanie wyrażeń typu Boolean}

Zastosowanie makr w przypadku projektu polega na zamianie wyrażeń typu Boolean na własną strukturę którą będzie można w prosty sposób serializować do języka Cypher. Strukturę tę rozpoczyna cecha Condition której potomkami są takie klasy jak And, Or, Not które odpowiednio reprezentują koniunkcję, alternatywę i zaprzeczenie warunków oraz PropertyComparison która odpowiada porównaniu pól obiektów z dziedziny.

OBRAZEK Z HIERARCHIĄ KLAS

Implementacja:

W makrach można wyszczególnić dwa rodzaje operacji. Są to przechodzenie drzewa składniowego i wyszukiwanie interesującyh wzorców oraz budowanie drzew składniowych wyrażeń którymi mają być zastąpione znalezione wzorce. Z tego powodu implementacja makra służącego do transformowania wyrażeń logicznych została podzielona na dwie części realizujące te dwa zadania.

Pierwszą z nich są tzw. klasy transformujące (ang. Transformers) które zajmują się wyszukiwaniem wzorców w drzewie i zamianą ich na docelowe wyrażenia oraz budowniczy (ang. Builders) zajmujący się tworzeniem drzewa składniowego wspomnianych wyrażeń. Odseparowanie tych dwóch czynności oraz wprowadzenie kilku poziomów w hierarchi klas pozwoliło na stworzenie prostego w analizie kodu wspomnianego makra co jest kluczowe gdyż mechanizm makr jest sam w sobie dość skomplikowany.  Ze względu na niewielką ilość kodu pozwoliłem sobie na zamieszczenie implementacji makra poniżej.

\lstinputlisting{listings/scala/boolean-macro-implementation.scala}

Jak widać, na poziomie implementacji logiki makra wszystko ogranicza się do wywołań kilku metod poprzedzonych sekcją dopasowywania do wzorca (ang. Pattern Matching) znanego z języka Scala.

\section{Serializacja do języka Cypher}

W każdym zapytaniu języka Cypher da się wyszczególnić kilka głównych składowych odpowiadającym odmiennym zadaniom. Przykładem może być chociażby zapytanie do wyszukiwania danych w grafie które składa się z sekcji Start, Match oraz Return. Te same sekcje pojawiają się również w innych rodzajach zapytań (jak chociażby w zapytaniu służącym do aktualizacji danych w grafie może pojawić się sekcja Start). Z tego powodu serializacja poszczególnych sekcji została wyciągnięta do osobnych obiektów realizujących serializację w sposób niezależny. Dzięki temu możliwe jest ponowne wykorzystanie kodu w przypadku implementacji różnych rodzajów zapytań.

\subsection{Struktura}

Głównym obiektem zajmującym się serializacją jest obiekt CypherSerializer. Jego zadaniem jest obsługa wszystkich rodzajów zapytań i delegewanie serializacji do poszczególnych klas serializujących które składają poszczególne sekcje w kompletne zapytanie.

Jedną z takich klas jest SelectSerializer która odpowiada za serializację zapytań typu Select służących do wydobywania danych z bazy. Realizuje ona swoje zadanie z wykorzystaniem obiektów odpowiedzialnych za poszczególne sekcje zapytań takie jak: StartSerializer, MatchSerializer, ReturnSerializer, WhereSerializer.

Aby wygenerowane sekcje były spójne pod względem używanych nazw zmiennych wykorzystywany jest obiekt implementujący interfejs NameResolver. Jego jedyną odpowiedzialnością jest przydzielanie nazw obiektom typu Node (wszystkie klasy dziedziczące po DomainObject dziedziczą również po Node). Domyślną implementacja którą jest BasicNameResolver przydziela nazwy według następującej konwencji. W przypadku węzłów o określonym identyfikatorze. Przydzielona nazwa to identyfikator z prefixem "id\_", pozostałym węzłom przydzielany jest kolejny wolny numer (zaczynając od 1) z prefixem "n\_". Oczywiście głównym wymogiem klasy implementującej ten interfejs jest by dla danego węzła zawsze zwracana była ta sama nazwa.

\section{Zwracanie wyników}

Istotnym zadaniem narzędzia miało być ukrycie wewnętrznych mechanizmów bazy danych i danie klientowi złudzenia pracy wyłącznie z klasami które sam zdefiniował. By osiągnąć ten cel na poziomie wykonywania zapytań bazodanowych zwracane dane muszą być przetransformowane do klas domenowych. Zadanie zostało zrealizowane z wykorzystaniem prostego "mappera" obiektowego polegającego na mechanizmie refleksji.

\subsection{Refleksja w Scali}

Język scala od wersji 2.10 udostępnia mechanizm refleksji dedykowany do tego języka. We wcześniejszych wersjach refleksja mogła być realizowana wyłącznie przy pomocy API udostępnianego razem z językiem Java. Refleksja pozwala na odczytywanie informacji o dowolnej klasie w trakcie działania programu. Informacje jakie można wyciągnąć to np. zdefiniowane pola, metody czy w szczególności konstruktory. Poza informacją o dostępnych polach istnieje również możliwość na modyfikacje pól, wywoływanie metod czy tworzenie nowych obiektów danego typu. Jest to zatem nieodzowny mechanizm stosowany przy implementacji narzędzi tworzących obiekty w sposób dynamiczny.

Oczywistą wadą refleksji jest dużo mniejsza wydajność niż w przypadku bezpośredniego operowania na klasie.

WYKRES Z PORÓWNANIEM WYDAJNOŚCI REFLEKSJI VS BEZPOŚREDNI DOSTĘP

\subsection{Mapper obiektowy}

Po wykonaniu zapytania baza danych zwraca wyniki w określonym przez siebie formacie. Może to być np. format JSON w przypadku RESTowej implementacji. Oczywiście narzędzia do obsługi bazy neo4j dostarczają natywnych narzędzi do obsługi wyników. Zajmują się one obsługą poszczególnych pól i rozpoznawaniem typu wartości. Stworzone narzędzie również udostępnia tego typu interfejsy mające na celu ujednolicić dostęp do różnych baz grafowych bądź różnych implementacji. Interfejsem opakowującym pojedyńczy wynik zapytania jest ResultItem. Zadaniem implementacji tego interfejsu jest dostarczanie struktury mapy hashującej która dla określonej nazwy pola zwraca jego wartość otrzymaną z silnika bazy danych. Jedyną dostępną implementacją jest Neo4jResultItem które zajmuje się tłumaczeniem wyników otrzymanych z serwisu REST.

Sam silnik bazodanowy powinien implementować interfejs ExecutionEngine. Interfejs ten wymaga by jego implementacja dostarczała wyłącznie jedną metodę jaką jest exec. Metoda ta powinna dla każdego obsługiwanego przez narzędzie zapytania zlecać wykonanie zapytania oraz zwrócić wyniki w postaci kolekcji obiektów typu ResultItem.

Oczywiście ResultItem jest dość ogólnym typem i nie odpowiada on strukturze stworzonej przez klienta naszej aplikacji. Potrzebny jest zatem mechanizm zajmujący się zamianą obiektów typu ResultItem na instancje klas wybranego typu definiowanego przez klienta aplikacji. Zadanie to realizuje tzw. ObjectMapper. Domyślna implementacja mappera tj. NodeObjectMapper wykorzystuje wspomniany już mechanizm refleksji. Tworzy on najpierw instancję danej klasy a następnie modyfikuje pola o takiej samej nazwie jak te określone w tablicy hashującej.

W swojej bieżącej implementacji nie wykorzystuje on żadnego mechanizmu cache'owania jednak nic nie stoi na przeszkodzie by w przyszłości wprowadzić taką warstwę i podnieść w znaczący sposób wydajność całego narzędzia.

\chapter{Przykłady wykorzystania}

W tym rozdziale postaram się zaprezentować kompletne przykłady zastosowania stworzonego narzędzia. Pierwszym z nich będzie sieć społecznościowa zawierająca kilka podstawowych relacji spotykanych w serwisach społecznościowych.

\subsection{Sieć społecznościowa}

Sieci społecznościowe koncentrują się w okół osób i relacji między nimi. Potrzeba zatem reprezentacji osób które będą przechowywane w bazie danych. Służyć do tego będzie prosta klasa Person zawierająca jedno pole name odpowiadające imieniu danej osoby. Poza polem opisującym osobę zawierać ona będzie pola określające relacje jakimi związana jest osoba z innymi obiektami naszej sieci społecznościowej. Relacjami są w tym przypadku "KNOWS" wiążąca znajomych oraz "WROTE" która zostanie opisana szczegółowo razem z obiektami typu Comment.

Person Snippet

Kolejnym obiektem składowanym w bazie będą komentarze reprezentowane przez klasę Comment. Typową relacją między osobą a komentarzem jest relacja autorstwa określająca kto napisał dany komentarz. Realizowana będzie ona za pomocą krawędzi "WROTE". Kolejną akcją dokonywaną na komentarzach jest głosowanie tj. wydanie aprobaty przez daną osobę. Relacja ta nazywa się "LIKES".

Comment snippet

\subsection{Zapytania w sieci społecznościowej}



\chapter{Zmiany w Neo4j 2.0 względem 1.x}

Stworzone narzędzie było projektowane z myślą o wersji 1.9.x która w momencie pisania większej części pracy była obowiązującym stabilnym wydaniem. Wersja druga przyniosła znaczące zmiany które wymagają omówienia (które stoją w sprzeczności z częścią opisanych tu mechanizmów).

Jedną z bardziej istotnych zmian jest tak zwany mechanizm etykietowania który pozwala na grupowanie węzłów. Poza możliwością określenia typu każdego węzła możliwe stało się nakładanie tzw. więzów (ang. Constraints) na określone typy. Pozwala to na definiowanie czegoś w rodzaju schematu bazy danych znanego z baz relacyjnych. Pojawienie się mechanizmu etykiet miało również wpływ na rozszerzenie języka Cypher. Możliwe jest np. wyszukiwanie wzorców z węzłami określonego typu.

Kolejnym mechanizmem który został gruntownie przebudowany jest indeksowanie. W przypadku wydań z serii 1.x narzut związany z obsługą indeksowania był zrzucony na programistę. W dodatku by wykorzystać dany indeks w zapytaniu trzeba było zażądać tego w sposób jawny w sekcji START. Obecnie indeksy dużo bardziej funkcjonalność znaną z baz relacyjnych. Nie ma potrzeby jawnego określania jaki indeks powinien zostać wykorzystany w zapytaniu natomiast zarządzanie indeksami stało się możliwe z poziomu języka Cypher.

Zmiany dotknęły również języka Cypher który jak określają twórcy stał się bardziej deklaratywny. Istotną zmianą jest np. opcjonalność sekcji START. Zapytania nie muszą zawierać jakichkolwiek węzłów początkowych niemniej zalecane jest ograniczanie zbioru węzłów po których odbywać będzie się wyszukiwanie. Pozostałe zmiany miały na celu uproszczenie składni.

\section{Potencjalne funkcjonalności}

\subsection{Aktualizacja danych}

% zakończenie 
\summary
Podsumowanie

% załączniki (opcjonalnie):
\appendix
\chapter{Tytuł załącznika jeden}

Treść załącznika jeden.

% literatura (obowiązkowo):
\bibliographystyle{unsrt}
\bibliography{master-thesis}

% spis tabel (jeżeli jest potrzebny):
\listoftables

% spis rysunków (jeżeli jest potrzebny):
\listoffigures

\oswiadczenie

\end{document}
