\documentclass[brudnopis]{xmgr}

\usepackage{listings}

% "define" Scala

\usepackage{lstlang0}

% Default settings for code listings
\lstset{frame=tb,language=Scala,aboveskip=3mm,belowskip=3mm,showstringspaces=false,columns=flexible,basicstyle={\small\ttfamily}}

%\defaultfontfeatures{Scale=MatchLowercase}
%\setmainfont[Numbers=OldStyle,Ligatures=TeX]{Minion Pro}
%\setsansfont[Numbers=OldStyle,Ligatures=TeX]{Myriad Pro}
% for fontspec version < 2.0
\setmainfont[Numbers=OldStyle,Mapping=tex-text]{Minion Pro}
\setsansfont[Numbers=OldStyle,Mapping=tex-text]{Myriad Pro}
%\setmonofont[Scale=0.75]{Monaco}

% Opcjonalnie identyfikator dokumentu 
% drukowany tylko z włączoną opcją 'brudnopis':
\wersja   {wersja wstępna [\ymdtoday]}

\author   {Mateusz Szygenda}
\nralbumu {186\,436}
\email    {mateusz.szygenda@gmail.com}

\title    {Wykorzystanie baz grafowych w języku Scala}
\date     {2014}
\miejsce  {Gdańsk}

\opiekun  {dr Wiesław Pawłowski}

% dodatkowe polecenia
%\renewcommand{\filename}[1]{\texttt{#1}}

\begin{document}

\begin{abstract}
Wstęp
\end{abstract}
\keywords{Scala, neo4j, DSL, języki domenowe, bazy grafowe}

% tytuł i spis treści
\maketitle

%
% wstęp
\introduction

W ostatnich latach można było zaobserwować pojawienie się wielu baz danych zrywających z niepodzielnie dotychczas panującym paradygmatem baz relacyjnych. Mowa tutaj o bazach nazywanych wspólnym hasłem ,,NoSQL" takich jak dokumentowa MongoDB czy też grafowa Neo4j. W określonych warunkach oferują one dużo większą wydajność niż bazy relacyjne. Oczywiście odbywa się to pewnym kosztem. W przypadku baz dokumentowych jest to zerwanie z normalizacją oraz transakcyjnością lub z całkowitą zmianą paradygmatu jak ma to miejsce w przypadku baz grafowych. Poszukiwanie wydajniejszych rozwiązań do składowania danych ma oczywiście swoją przyczynę. Jest to mianowicie fakt iż współczesne aplikacje internetowe muszą obsługiwać miliony użytkowników w czasie rzeczywistym. Baza danych która jest niejednokrotnie głównym elementem układanki musi oczwyiście sprostać tym wymaganiom. Okazuje się jednak, że w przypadku danych w których rekordy są ze sobą ściśle powiązane wieloma zależnościami bazy relacyjne mogą okazać się niewystarczające. Wynika to ze sposobu w jaki zależności te są modelowane bazach relacyjnych. Wykorzystywany mianowicie jest mechanizm kluczy obcych, natomiast na poziomie języka zapytań wykonywany jest iloczyn kartezjański co przy dużej ilości danych i~kilku relacjach może być bardzo kosztowne -- zarówno pod względem czasu, jak i wykorzystywanej pamięci. Z punktu widzenia użytkownika jest całkowicie nie do zaakceptowania by obsłużenie jego żądania zajmowało czas rzędu kilkunastu sekund lub nawet minut (ODNOŚNIK DO PORÓWNANIA WYDAJNOŚCIOWEGO). Potrzeba zatem wydajnego mechanizmu, który byłby w stanie spełnić rygorystyczne wymogi wydajnościowe oraz dobrze radzić sobie z danymi powiązanymi wieloma relacjami. Odpowiedzią są bazy grafowe, które do reprezentowania danych stosują strukturę grafu. Jak zostanie to wyjaśnione  w dalszych rozdziałach ma to znaczący wpływ na wydajność i sposób operowania na danych. Celem pracy było stworzenie narzędzia dla języka Scala pozwalającego na efektywne wykorzystanie jednej z najbardziej popularnych baz grafowych. Język ten został wybrany ze względu na dostępność licznych mechanizmów ułatwiających definiowanie tzw. języków dziedzinowych (DSL).

\chapter{Bazy grafowe}

\section{Wstęp}

Z matematycznego punktu widzenia (ODNOŚNIK DO KSIĄŻKI) graf to struktura składająca się ze zbioru wierzchołków oraz zbioru krawędzi. Krawędź reprezentuje połączenie pomiędzy dwoma wierzchołkami. W przypadku gdy kierunek krawędzi jest istotny mówimy o krawędziach skierowanych. Bazy grafowe wykorzystują właśnię tę strukturę reprezentowania wszystkich danych rozszerzając ją tylko w nieznaczny sposób (np. dodając pojęcie nazwanych krawędzi). Pomimo faktu iż teoria grafów jest dziedziną niemłodą i znaną od dłuższego czasu to same bazy grafowe są stosunkowo świeżym tworem. Jak wspomina autor bazy Neo4j, w roku 1999 nie istniała praktycznie żadna baza grafowa mogąca być wykorzystana w sposób produkcyjny (ODNOŚNIK DO KSIĄŻKI). Sposób w jaki bazy grafowe prezentują dane implikuje odmienny sposób przeszukiwania i operowania na zbiorze danych. Nie istnieje tutaj pojęcie tabeli znane z baz relacyjnych takich jak MySQL która narzucała by określoną strukturę. Zamiast tego mamy tu do czynienia z wierzchołkami (nazywanymi w dalszej części pracy zamiennie węzłami) które mogą zawierać dowolną liczbę pól prostych lub złożonych (jak ma to miejsce np. w bazie OrientDB). Pod tym względem przypominają one bazy dokumentowe w których również nie ma narzuconej struktury. W odróżnieniu jednak zarówno od baz relacyjnych jak i dokumentowych relacje między obiektami są zapisywane tutaj za pomocą nazwanych i skierowanych krawędzi. Pojedyńczy węzeł może mieć dowolnie wiele różnych krawędzi wychodzących jak i wchodzących (w dalszej części pracy będziemy używać zamiennie terminu krawędzi i relacji). Przeszukiwanie baz grafowych odbywa się poprzez definiowanie interesujących wzorców w grafie. Dzięki efektywnym algorytmom przeszukiwania grafów taki sposób przechowywania danych ma znaczący wpływ na wydajność.

Oto przykład ukazujący porównanie wydajności grafowej bazy Neo4j oraz MySQL dla analogicznej struktury danych i zapytań skupionych wokół relacji.

WYKRES Z MODELEM I ZAPYTANIEM SQL (Pożyczony z książki o neo4j)

WYKRES Z MODELEM I ZAPYTANIEM CYPHER (Pożyczony z książki o neo4j)

WYKRESY Z WYDAJNOŚCIĄ (Pożyczony z książki o neo4j)

Znacząca przewaga neo4j wynika tutaj przede wszystkim z lokalności operacji wykonywanych na danych (tj. nie musimy przeszukiwać wszystkich węzłów a jedynie te które są fizycznie połączone z interesującymi węzłami) w przeciwieństwie do bazy MySQL w której z każdym złączeniem relacji musimy utworzyć iloczyn kartezjański który wymaga przejrzenia całego zbioru danych.

\section{Rodzaje baz grafowych}

\subsection{Bazy z relacyjnym magazynem danych}

Rozróżniamy dwa główne rodzaje baz grafowych. Pierwszym z nich są bazy które pozwalają operować na przechowywanych danych jak na grafach, mających jednak odmienny sposób składowania danych. Popularnym rozwiązaniem jest np. przechowywanie struktury grafowej w bazach relacyjnych. Niestety takie rozwiązanie nie pozwala na pełne wykorzystanie potencjału drzemiącego w przechowywaniu danych w postaci grafów. Przykładem takiej bazy jest FlockDB która znajduje zastosowanie w popularnym serwisie społecznościowym Twitter. Ze względu na małą uniwersalność tego typu rozwiązań (zazwyczaj są one dostosowane do konkretnego przypadku użycia) bazy tego typu nie będą omawiane w tej pracy.

\subsection{Bazy z grafowym magazynem danych}
Drugim rodzajem baz grafowych są natywne bazy grafowe które nie tylko przedstawiają dane w formie grafów ale również wykorzystują strukturę grafów do ich składowania. Zaletą takiego podejścia jest to iż przeszukiwanie może okazać się o wiele wydajniejsze niż równoważne zapytanie do bazy z relacyjnym magazynem danych. Powodem tego jest lokalność operacji wykonywanych na grafie. W odróżnieniu od baz relacyjnych gdzie by wyszukać dane powiązane pewną relacją wymagane jest wykonanie iloczynu kartezjańskiego na całych zbiorach danych. W przypadku ogromnej liczby rekordów taka operacja może okazać się wielce niewydajna. W przypadku baz grafowych nie ma potrzeby odwiedzania wszystkich danych bowiem poruszamy się tylko w obrębie obiektów w bezpośredni sposób związanych ze sobą krawędziami. Przykładem takiej bazy jest np. Neo4J której została poświęcona znaczna część tej pracy.

\chapter{Neo4j}

Neo4j jest natywną bazą grafową napisaną w języku Java. Pozwala ona na przechowywanie węzłów jak i relacji wraz z polami typów prostych takimi jak napisy czy liczby. W implementacji zostało zastosowanych wiele mechanizmów mających na celu osiąnięcie jak najlepszej wydajności przy przeszukiwaniu grafów. Warto tutaj wymienić chociażby sposób w jaki zapisywana jest informacja o krawędziach wychodzących z wierzchołka. Otóż, aby odczytać listę krawędzi dla danego wierzchołka nie ma potrzeby korzystania z żadnego pośredniczącego indeksu, informację tę można odczytać bezpośrednio w jednym kroku (ang. Index-Free Adjacency). Wierzchołki i krawędzie są natomiast zapisywane w plikach w których każdy rekord jest stałego rozmiaru. Pozwala to na bardzo szybkie odczytywanie danych bez konieczności przeglądania pliku w celu odnalezienia właściwego rekordu (wystarczy pomnożyć rozmiar rekordu relacji bądź węzła przez jego identyfikator by uzyskać lokalizację w pliku).

Neo4j jest wydajną i jedną z bardziej rozpoznawalnych baz grafowych. Z tego powodu została ona wybrana do implementacji narzędzia będącego przedmiotem tej pracy.

\section{Język Cypher}
Cypher jest językiem zapytań stworzonym specjalnie na potrzeby neo4j pozwalającym w sposób deklaratywny przeszukiwać oraz aktualizować bazę grafową. Podobnie jak SQL jest to stosunkowo łatwy w analizie język który oferuje duże możliwości. Podrozdział ten ma na celu zaznajomienie czytelnika z podstawową składnią i sposobem w jaki operuje się na danych w bazach grafowych.

\subsection{Przeszukiwanie grafu}

Najistotniejszą funkcjonalnością baz danych jest możliwość przeszukiwania zbioru rekordów. Zapytanie służące do odczytywania informacji składa się z trzech podstawowych części.

Sekcja \texttt{START} pozwala na ustalenie węzłów startowych od których zacznie się przeszukiwanie grafu. Wierzchołki można wydobyć na podstawie ich wewnętrznego identyfiaktora lub z wykorzystaniem przygotowanego wcześniej indeksu. Sekcja ta do wersji 2.0 była obligatoryjna i mimo iż w nowych wersjach możliwe jest jej całkowite pominięcie zalecane jest aby zawsze określać węzły startowe. Bez tego zapytanie traci zaletę lokalności gdyż do później zdefiniowanego wzorca będzie dopasowany każdy węzeł znajdujący się w bazie danych. Poniższy przykład ilustruje sposób w jaki można określić wierzchołki początkowe. Zmiennej comment przypisany jest węzeł o wewnętrznym identyfikatorze równym 1, natomiast john będzie wskazywał na węzły znajdujące się w indeksie nazwanym \texttt{nameIndex} oraz zawierające pole \texttt{name} o wartości równej ,,John"

\lstinputlisting{listings/cypher/start-section.cypher}

Sekcja \texttt{MATCH} jest główną częścią zapytania, pozwala ona bowiem określić interesujące nas wzorce w grafie. Część ta jest swego rodzaju ,,odpowiednikiem" instrukcji INNER JOIN w języku SQL gdyż pozwala nam określić relacje pomiędzy węzłami. Poniżej został zdefiniowany jeden wzorzec który pozwala wyszukać znajomych johna ,,lubiących" komentarz wskazywany przez zmienną \texttt{comment}

\lstinputlisting{listings/cypher/match-section.cypher}

Ostatnim elementem zapytania jest sekcja \texttt{RETURN} służąca określania pól które mają zostać zwrócone jako wynik. W poniższym przykładzie zwrócone zostanie pole \texttt{name} oraz wewnętrzny identyfikator węzłów dopasowanych do zmiennej \texttt{friend}.

\lstinputlisting{listings/cypher/return-section.cypher}

Pełne zapytanie wygląda zwraca identyfikator oraz pole \texttt{name} węzłów które są połączone krawędzią o nazwie \texttt{KNOWS} z obiektem \texttt{john} oraz będące połączone krawędzią \texttt{LIKES} z obiektem o identyfikatorze równym {1}. Poruszając się w domenie sieci społecznościowej zapytanie zwraca znajomych użytkownika ,,John" którzy polubili komentarz o identyfikatorze {1}.

\lstinputlisting{listings/cypher/sample-query.cypher}

\subsection{Modyfikacja danych}

Język Cypher pozwala również na aktualizację danych w grafie. Podobnie jak w przypadku zapytania służącego do przesukiwania grafu wyrażenie składa się kilku części.

Pierwszą z nich ponownie jest sekcja \texttt{START}, która pozwala na wybranie wezłów zakotwiczających tworzony wzorzec w strukturze grafu. Jest ona opcjonalna jeśli zamierzamy utworzyć graf niepowiązany z istniejącymi już wierzchołkami.

\lstinputlisting{listings/cypher/start-section.cypher}

Kolejną sekcją jest \texttt{CREATE} której składnia jest podobna do sekcji \texttt{MATCH}. W przeciwieństwie jednak do \texttt{MATCH} pozwala ona na tworzenie krawędzi w grafie oraz węzłów. W poniższym przykładzie zostanie utworzony węzeł \texttt{newFriend} o polu \texttt{name} równym wartości ,,New friend" oraz relacja \texttt{KNOWS} łącząca wierzchołek wskazywany przez zmienną \texttt{john} z nowo utworzonym węzłem.

\lstinputlisting{listings/cypher/create-section.cypher}

Ostatnim elementem jest wykorzystana już wcześniej sekcja RETURN która pozwala na zwrócenie informacji o nowoutworzonych obiektach takich jak ich identyfikatory.

\lstinputlisting{listings/cypher/return-section-2.cypher}

Pełne zapytanie wstawiające do grafu nowy obiekt o polu \texttt{name} równym ,,New Friend" i łączące go z obiektami \texttt{john} oraz \texttt{comment} wygląda następująco

\lstinputlisting{listings/cypher/sample-create-query.cypher}

\section{Programistyczne sposoby dostępu do neo4j}

Neo4j udostępnia kilka odmiennych sposobów dostępu do bazy. Rozdział ten ma na celu przedstawienie każdego z nich.

\subsection{Embedded mode}

Jedną z możliwości jest tzw. embedded mode który polega na wykorzystaniu udostępnionego API dla języka Java. Polega to na wykorzystaniu wewnętrznych struktur bazy. Rozwiązanie idealnie nadaje się w przypadku gdy potrzebna jest większa kontrola nad bazą danych i potrzebne są bardziej zaawansowane mechanizmy wyszukiwania danych. Oczywistą wadą jest fakt, że do wykorzystania tego mechanizmu potrzebna jest lokalna instancja bazy danych.

\subsection{REST mode}

\subsection{Zapytania Cypher}

\chapter{Język Scala}

Scala jest statycznie typowanym językiem programowania który łączy w sobie idee programowania obiektowego oraz funkcyjnego. Połączenie tych dwóch paradygmatów było jednym ze środków do osiągnięcia głównego z założeń twórców jakim było stworzenie języka, który jest skalowalny oraz zwięzły. Skalowalność w tym przypadku polega na przystosowaniu języka do prostych zadań jak np. niewielkie skrypty oraz do ogromnych projektów jakie realizuje się w językach typu Java czy C\#.

Do dyspozycji programisty zostało oddanych szereg mechanizmów pozwalających na ,,rozszerzanie" składni języka. Jednym z nich jest np. możliwość definiowania operatorów takich jak\texttt{*}, \texttt{+}, \texttt{-} oraz wywoływania ich w postaci infixowej. Pozwala to na budowanie złożonych klas których użycie przypomina zwykłe wyrażenia arytmetyczne, które w większości języków programowania są obsługiwane w sposób szczególny. Scala jest natomiast tak elastycznym narzędziem iż pozwala nawet na definiowanie znanych struktur kontrolnych takich jak np. pętla while (jest to zasługa tego iż Scala jest językiem funkcyjnym i funkcje mogą być przekazywane jak zwykłe obiekty).

Pomimo faktu iż jest to język statycznie typowany, nie wymaga on od programisty jawnego określania typu w każdej sytuacji. System inferencji typów jest na tyle rozbudowany iż w wielu przypadkach możliwe jest całkowite pominięcie określania typów zmiennych. Jest to kolejna cecha poza wieloma innymi wpływająca na zwięzłość kodu pisanego w tym języku.

Właśnie z powodów zwięzłości oraz łatwości z jaką możliwe jest rozszerzanie składni, Scala została wybrana do stworzenia języka dziedzinowego do obsługi baz grafowych.

\subsection{Programowanie funkcyjne}

Języki takie jak Java, C\# czy C++ są obiektowymi językami programowania opartymi na paradygmacie programowania imperatywnego. Zakłada on istnienie stanu w programie który podlega ciągłej zmianie. Przeciwieństwem tego podejścia jest programowanie funkcyjne w którym nie istnieje stan a funkcje przekształcają dane wejściowe w wyjściowe bez tzw. efektów ubocznych. Kolejną cechą języków funkcyjnych jest to iż funkcje są traktowane jak zwykłe wartości. Możliwe jest na przykład przechowywanie funkcji w zmiennych, przekazywanie ich jako parametry innych funkcji w identyczny sposób jak dzieje się to z instancjami typów String czy Integer. Scala łączy te dwa odmienne podejścia dając programiście swobodę w wyborze przy implementacji programów.

\subsection{Podstawy składni}
Składnia Scali była inspirowana takimi językami jak C\# czy Java stąd doświadczonym programistom nie powinno sprawiać trudności czytanie kodu języka Scala. Oczywiście jak zostało to już wspomniane w odróżnieniu od wspomnianych języków Scala wprowadza szereg usprawnień wpływających na zwięzłość pisanego kodu. Nie ma np. potrzeby kończenia każdej linii średnikiem czy jawnego określania typu każdej zmiennej (o ile system interferencji jest w stanie określić jej typ).

Istotną różnicą w stosunku do Javy czy C\# wpływającą na czytelność kodu jest sposób w jaki definiuje się zmienne czy parametry metod. Mianowicie, najpierw określa się ich nazwy a w drugiej kolejności typ (który może być całkowicie pominięty jeśli da się go określić z systemu inferencji). Taka kolejność wynika z faktu iż programista czytający kod bardziej zainteresowany jest nazwą aniżeli typem zmiennej. Poniżej kilka przykładowych deklaracji stałych i zmiennych.

\lstinputlisting{listings/scala/val-var-declarations.scala}

Metody w języku scala definuje się z użyciem słowa kluczowego \texttt{def}. Podobnie jak w przypadku zmiennych typ zwracanej wartości określany jest po zdefiniowaniu nazwy i może być on całkowicie pominięty jeśli da się go określić z ciała metody. Poniżej przykłady kilku funkcji.

\lstinputlisting{listings/scala/functions-example.scala}

Klasy definiuje się z użyciem słowa kluczowego \texttt{class} podobnie jak ma to miejsce w Javie. To na co warto zwrócić uwagę to fakt iż klasy języka Scala posiadają tzw. konstruktor główny. Jego parametry wejściowe określa się bezpośrednio po nazwie klasy natomiast jego implementacja powinna być zawarta bezpośrednio w ciele klasy. W ramach listy parametrów konstruktora głównego możliwe jest również zdefiniowanie pól składowych klasy z użyciem słów kluczowych val lub var (służą one odpowiednio do deklarowania stałych lub zmiennych). Wszelkie przęciążone konstruktory (które definiuje się podobnie jak w Javie) muszą skorzystać w sposób pośredni lub bezpośredni z konstruktora głównego.

Poniżej przedstawiona jest prosta klasa Person w języku Scala. W konstruktorze głównym zdefiniowane zostały dwa pola składowe: \texttt{name} oraz \texttt{age}.

\lstinputlisting{listings/scala/simple-class-person.scala}

Poza tym klasa zawiera jedną metodę \texttt{sayHello} która wyświetla komunikat.
Zdefiniowanej powyżej klasie odpowiada poniższy kod w języku Java.

\lstinputlisting{listings/java/simple-class-person.java}

\subsection{Pattern Matching}

Jednym z bardziej istotnych mechanizmów języka niespotykanym w takich językach jak Java jest tzw. Pattern Matching (dopasowywanie do wzorca). Pozwala on na definiowanie specjalnych klas (ang. Case Classes) które można dopasowywać i wyciągać ich składowe z wykorzystaniem specjalnej składni. Przypomina to trochę instrukcję \texttt{switch} o dużo bardziej zaawansowanym działaniu. Oto przykład pozwalający na wyświetlenie wartości przechowywanych w liściach struktury drzewa reprezentowanej właśnie przy pomocy tzw. case classes.

\lstinputlisting{listings/scala/pattern-matching-trees.scala}

Pattern matching znajduje zastosowanie w neodsl chociażby na etapie serializacji struktury zapytań baz grafowych do języka natywnego obsługiwanego przez konkretną bazę.

\chapter{Dostęp do baz danych z wykorzystaniem DSL}

Wszystkie bazy danych udostępniają pewien natywny interfejs do manipulacji na przechowywanych rekordach. W przypadku baz relacyjnych mamy do dyspozycji język SQL. O ile np. sam język SQL jest prostym w użyciu narzędziem to rzadko kiedy z poziomu tworzonego programu chcemy korzystać z niego w sposób bezpośredni. Potrzebna jest pewna warstwa abstrakcji która ukryje przed programistą różnice w implementacji SQLa w różnych bazach relacyjnych jak i uchroni przed typowymi błędami takimi jak nie oczyszczanie danych pochodzących od użytkownika (prowadzących np. do ataków SQL Injection). Rozwiązaniem tego problemu są tzw. mappery bazodanowe takie jak Hibernate. Udostępniają one mechanizmy które pozwalają na zdefiniowanie powiązania pomiędzy klasami programu a tabelami/kolekcjami w bazie danych. Narzędzia te zajmują się tłumaczeniem wywołań odpowiednich metod na zapytania języka obsługiwanego przez daną bazę. Oprócz tego zamiast generycznych obiektów reprezentujących wyniki zapytań zwracają one instancje klas, które reprezentują poszczególne rekordy (np. instancje klas typu Osoba, Komentarz).

Alternatywą dla klasycznych rozwiązań typu Hibernate są języki dziedzinowe (ang. Domain Specific Language) w skrócie DSL pozwalające w pewnym uproszczeniu na zapisywanie zapytań języka bazy danych wprost w kodzie programu. Tak budowane zapytania są zwykłymi wywołaniami metod danego języka stąd są automatycznie walidowane na etapie kompilacji.

Rozdział ten ma na celu przedstawienie istniejących rozwiązań dla baz relacyjnych jak i NoSQL będących inspiracją dla tworzonego narzędzia.

\section{Bazy SQL}

\subsection{Squeryl}

Sztandarowym przykładem DSLa bazodanowego dla języka Scala jest projekt Squeryl. Umożliwia on zdefiniowanie struktury bazy danych w kodzie programu a następnie budowania zapytań z wykorzystaniem zdefiniowanej wcześniej struktury.

Pierwszym etapem w przypadku narzędzia Squeryl jest stworzenie odwzorowania struktury bazy danych. Definiuje się ją z wykorzystaniem zwykłych klas języka Scala oraz specjalnej klasy Schema. Przykładowa struktura (przykład z dokumentacji Squeryla)

\lstinputlisting{listings/scala/squeryl-schema.scala}

Powyższa struktura odwzorowuje bardzo prostą bazę danych z jedną tabelą ,,Song" służącą do przechowywania informacji o utworach muzycznych. Z wykorzystaniem tak zdefiniowanych klas możliwe jest budowanie zapytań. Oto przykładowe z nich

\lstinputlisting{listings/scala/squeryl-query.scala}

Służy ono do wyszukiwania piosenek które w tytule zawierają słowo ,,funk". Powyższe wyrażenie odpowiada mniej więcej takiemu zapytaniu w języku SQL.

\lstinputlisting{listings/sql/squeryl-query.sql}

Zastosowanie języka dziedzionowego pozwala w pełniejszy sposób wykorzystać możliwości języka bazy danych przy jednoczesnym zachowaniu zalet rozwiązań typu Hibernate (tj. odwzorowywanie wyników na obiekty oraz kontrola wyrażeń na etapie kompilacji)

\section{Bazy NoSQL}

MongoDB jest jedną z popularniejszych baz dokumentowych. Pozwala ona na przechowywanie tzw. dokumentów tj. złożonych wartości które mogą być dowolnie zagnieżdżane. Oferuje ona dużą wydajność kosztem zerwania normalizacją i brakiem transakcyjności.

\subsection{Rogue}
Jedną z bibliotek do obsługi MongoDB z poziomu języka Scala jest Rogue. Podobnie jak Squeryl udostępnia ona DSL służący do budowania zapytań. Oto przykładowa klasa modelu składowanego w MongoDB

\lstinputlisting{listings/scala/rogue-model.scala}

Do definiowania pól konieczne jest tworzenie obiektów rozszerzających cechę Field. Rogue wymaga od programisty napisania nieco więcej kodu niż Squeryl. Zaprezentowane rozwiązanie ma jednak tę zaletę iż dzięki specjalnym typom jak np. LongField dużo łatwiejsze stało się tworzenie DSLa który nie musi zajmować się obsługą typów wbudowanych w język Scala.

Przykładowe zapytanie przedstawione jest poniżej

\lstinputlisting{listings/scala/rogue-query.scala}

\chapter{DSL do baz grafowych}

W celu zaprezentowania jednego ze sposobów w jaki można wykorzystać bazy grafowe w nowoczesnych językach jak Scala powstało narzędzie ,,neodsl". Jest to DSL służący do obsługi baz grafowych. W bieżącej implementacji obsługiwana jest tylko jedna z nich, mianowicie Neo4j (stąd projekt wziął swą nazwę). 

Głównym elementem zapytań w przypadku baz grafowych są wzorce stąd narzędzie do ich obsługi powinno pozwalać na budowanie dowolnie długich dopasowań. Podobnie jak w bibliotece Squeryl, w ,,neodsl'' przed tworzeniem jakichkolwiek zapytań trzeba zdefiniować strukturę bazy danych. Inaczej jednak niż w przypadku Squeryla definiowanie struktury odbywa się wyłącznie na poziomie klas domenowych. Nie ma potrzeby tworzenia jednego specjalnego obiektu skupiającego w sobie wszystkie powiązania. Dzięki określonej strukturze możliwe jest budowanie silnie typowanych wzorców i całych zapytań. Jest to niewątpliwą zaletą w stosunku do ręcznego pisania zapytań języka Cypher. Oczywiście wszystko będzie odpowiadało strukturze bazy pod warunkiem, że model został poprawnie zdefiniowany. Przypomnijmy, że w bazach takich jak Neo4j nie istnieje pojęcie schematu i nie ma z góry określonej struktury. To programista lub narzędzie do obsługi bazy musi zapewnić spójność w tym aspekcie.

\section{Definiowanie modelu}

Pierwszym krokiem jaki należy wykonać przed definiowaniem zapytań jest utworzenie modelu (tj. zbioru klas) odpowiadającego jakiemuś fragmentowi rzeczywistości który opisujemy i przechowujemy w bazie danych. Neodsl udostępnia mechanizmy pomocnicze które pozwalają na szybkie odwzorowanie węzłów oraz relacji między nimi.

\subsection{Klasa \texttt{DomainObject}}

Wszystkie klasy domenowe powinny rozszerzać klasę \texttt{DomainObject} która dostarcza narzędziu niezbędnych informacji do działania. Jest to klasa generyczna tj. klasa przyjmująca dodatkowy parametr będący typem. Typ ten powinien odpowiadać klasie którą definiuje programista. Konieczność przekazywania typu definiowanej klasy jest technicznym szczegółem, który wymagany jest do prawidłowego funkcjonowania narzędzia.

Definiowane klasy mogą zawierać dowolne pola proste dostępne w języku Scala tj. \texttt{Int}, \texttt{Byte}, \texttt{Short}, \texttt{Char}, \texttt{Long}, \texttt{Double}, \texttt{Float}, \texttt{String}.

\subsection{Relacje}

Najistotniejszą informacją w przypadku baz grafowych są relacje czy też krawędzie wychodzące z węzłów danego typu. Należy je zdefiniować jako pola w klasie domenowej. Nie ma oczywiście potrzeby tworzenia obiektów w sposób ręczny gdyż klasa DomainObject udostępnia metody pomocnicze pozwalające na definiowanie relacji. Są to metody  -->, <--, -- które jednocześnie określają kierunek. Metody te są generyczne i pozwalają na określenie typu obiektów pomiędzy którymi zachodzić będzie relacja. Przyjmują one jeden parametr typu \texttt{String} który pozwala na zdefiniowanie nazwy relacji czy też krawędzi.

\subsection{Przykład modelu}

Oto przykładowa klasa domenowa reprezentująca osobę. Zawiera ona pola takie jak \texttt{name}, \texttt{surname} odpowiadające imieniu i nazwisku osoby oraz pola definiujące krawędzie wchodzące i wychodzące z węzłów tego typu. Są to relacje \texttt{knows} która definiuje krawędź wychodzącą do obiektów typu \texttt{Person} oraz \texttt{wrote} która jest relacją skierowaną do naszego obiektu i jest powiązana z obiektem typu \texttt{Comment}.

\lstinputlisting{listings/scala/dsl/sample-model.scala}

\section{Budowanie wzorców}

Zapytania w bazach grafowych skupiają się na wyszukiwaniu określonych wzorców. Z tego powodu główny nacisk w obrębie zwięzłości tworzonego DSLa został położony właśnie na tej części.

\subsection{Podstawowa struktura -- klasa \texttt{PatternTriple}}
Podstawową strukturą służącą do reprezantacji wzorców jest klasa PatternTriple. Jak sugeruje jej nazwa składa się ona z trzech elementów. Są to kolejno: węzeł początkowy, relacja z określonym kierunkiem oraz tzw. ,,ogon" wzorca. Wspomniany ,,ogon" może być zarówno pojedyńczym węzłem jak i kolejną instancją PatternTriple. Taka struktura pozwala na budowanie w sposób rekurencyjny dowolnie długich wzorców. Warto również dodać iż klasa PatternTriple jest generyczna i posiada z góry określone typy węzłów jakie mogą pojawiać się w dalszej części wzorca.  Niemożliwe jest zatem utworzenie instancji wzorca w której zachodziła by niezgodność typów (o to zadba kompilator języka Scala).

\subsection{Budowniczy wzorców \texttt{PatternBuilder}}
Aby uprościć budowanie trójek wzorca została przygotowana klasa PatternBuilder, która jak sugeruje jej nazwa służy do budowania wzorców (nazywana dalej ,,budowniczym"). Udostępnia ona szereg metod pomocniczych pozwalających na budowanie i rozszerzanie istniejących instancji PatternTriple. Tworzenie instancji budowniczego jest niezwykle proste i odbywa się na etapie definiowania klas domenowych, mianowicie to wspomniane już wcześniej metody -->, <--, -- zwracają instancje klasy PatternBuilder.

Oto przykładowe złożenie kilku wzorców. Wykorzystana została tutaj zaprezentowana wcześniej struktura sieci społecznościowej. Pojawiajace się poniżej zmienne \texttt{john}, \texttt{friend}, \texttt{matthew} są instancjami typu \texttt{Person} podczas gdy \texttt{wiseComment} jest obiektem typu \texttt{Comment}.

\lstinputlisting{listings/scala/dsl/patterns/functional-example-1.scala}

Wynikiem powyższego wyrażenia jest instancja tzw. złożenia wzorców, mamy tutaj bowiem do czynienia z trzema wzorcami połączonymi operatorem logicznym ,,and". 

\section{Nakładanie warunków na wyniki zapytań}

Jednym z bardziej istotnych mechanizmów przy przeszukiwaniu baz danych jest możliwość nakładania warunków na zwracane wyniki. Założeniem projektu było aby dało się wyrażać warunki logiczne bez potrzeby wprowadzania nowej składni innej niż ta dostarczana przez sam język Scala. 
Aby osiągnąć ten cel potrzebny jest mechanizm pozwalający na analizę wyrażeń typu \texttt{Boolean}. Język Scala udostępnia mechanizm makr pozwalający na analizę i modyfikację wyrażeń języka, w szczególności wyrażeń typu \texttt{Boolean}. Dzięki temu, możliwe jest po uprzedniej analizie wyrażenia typu \texttt{Boolean} utworzenia struktury rozpoznawanej przez neodsl którą można w prosty sposób zamienić na wyrażenie języka Cypher.

\subsection{Makra}

Makra są eksperymentalną funkcjonalnością języka Scala wprowadzone w wersji WERSJA. Są one, podobnie jak w przypadku makr znanych z języka C, wykonywane podczas etapu kompilacji jednak dają o wiele więcej możliwości. Najważniejszą różnicą w stosunku do wspomnianego C jest fakt, że makra języka Scala nie definiują żadnego specyficznego dla tego typu zadań mini-języka. Zamiast tego mogą być pisane w języku Scala. Co więcej nie ograniczają się one do prostej zamiany tekstu w kodzie programu jak to bywa w przypadku innych języków ale pozwalają na modyfikację drzewa składniowego. Oczywiście jest to dużo bardziej zaawansowany mechanizm i jego właściwe wykorzystanie jest bardziej skomplikowane, niemniej w zamian otrzymujemy bardzo potężny mechanizm.

Samo definiowanie makra jest stosunkowo proste. Wystarczy utworzyć obiekt (w językach typu Java realizowany za pomocą wzorca Singleton, w Scali istnieje dedykowana instrukcja) z dowolnie nazwaną metodą która docelowo ma służyć do wykonywania makra. W przeciwieństwie do zwykłych metod, nie powinna ona zawierać ciała a jedynie słowo kluczowe \texttt{macro} wraz z nazwą metody która implementuje dane makro. Najbardziej interesującym elementem jest właśnie metoda implementująca makro. Zawiera ona dwie listy parametrów. Pierwsza z nich zawiera jeden parametr tzw. kontekst (typu \texttt{Context}) skupiający w sobie wszystkie zebrane przez kompilator informacje na temat kodu programu. Druga lista zawiera drzewa składniowe wyrażeń jakie zostały przekazane do makra w postaci argumentów. Zwracaną wartością jest drzewo składniowe które zostanie wstawione w miejscu wywołania makra. Mechanizm wydaje się dość skomplikowany jednak w efekcie służy do zamiany pewnych wyrażeń w kodzie programu na inne podczas etapu kompilacji.

Przykładowa definicja makra powinna nieco rozjaśnić sposób ich użycia.

\lstinputlisting{listings/scala/macro-sample.scala}

W powyższym przykładzie zdefiniowane zostało makro o nazwie assert przyjmujące dwa argumenty. Pierwszym z nich jest wyrażenie typu \texttt{Boolean}, kolejny to wiadomość która powinna zostać wyświetlona w przypadku gdy wyrażenie logiczne okaże się fałszywe. Przykładowe zastosowanie makra w tym przypadku to np. zamiana wyrażenia logicznego na napis i wypisanie go w całości w przypadku gdy asercja nie jest spełniona.

\subsection{Przetwarzanie wyrażeń typu \texttt{Boolean}}

Zastosowanie makr w przypadku neodsl polega na zamianie wyrażeń typu \texttt{Boolean} na własną strukturę którą będzie można w prosty sposób serializować do języka Cypher. 
Strukturę tę rozpoczyna cecha \texttt{Condition} której potomkami są takie klasy jak \texttt{And}, \texttt{Or}, \texttt{Not} które odpowiednio reprezentują koniunkcję, alternatywę i zaprzeczenie warunków oraz \texttt{PropertyComparison} która odpowiada porównaniu pól obiektów z dziedziny.

OBRAZEK Z HIERARCHIĄ KLAS

Implementacja:

W makrach można wyszczególnić dwa rodzaje operacji. Są to przechodzenie drzewa składniowego i wyszukiwanie interesującyh wzorców oraz budowanie drzew składniowych wyrażeń którymi mają być zastąpione znalezione wzorce. Z tego powodu implementacja makra służącego do transformowania wyrażeń logicznych została podzielona na dwie części realizujące te dwa zadania.

Pierwszą z nich są tzw. klasy transformujące (ang. Transformers) które zajmują się wyszukiwaniem wzorców w drzewie i zamianą ich na docelowe wyrażenia oraz budowniczy (ang. Builders) zajmujący się tworzeniem drzewa składniowego wspomnianych wyrażeń. Odseparowanie tych dwóch czynności oraz wprowadzenie kilku poziomów w hierarchi klas pozwoliło na stworzenie prostego w analizie kodu wspomnianego makra co jest kluczowe gdyż mechanizm makr jest sam w sobie dość skomplikowany.  Ze względu na niewielką ilość kodu pozwoliłem sobie na zamieszczenie implementacji makra poniżej.

\lstinputlisting{listings/scala/boolean-macro-implementation.scala}

Jak widać, na poziomie implementacji logiki makra wszystko ogranicza się do wywołań kilku metod poprzedzonych sekcją dopasowywania do wzorca (ang. Pattern Matching) znanego z języka Scala.

\section{Serializacja do języka Cypher}

W każdym zapytaniu języka Cypher da się wyszczególnić kilka głównych składowych odpowiadającym odmiennym zadaniom. Przykładem może być chociażby zapytanie do wyszukiwania danych w grafie które składa się z sekcji \texttt{START}, \texttt{MATCH} oraz \texttt{RETURN}. Te same sekcje pojawiają się również w innych rodzajach zapytań (jak chociażby w zapytaniu służącym do aktualizacji danych w grafie może pojawić się sekcja \texttt{START}). Z tego powodu kod służący do serializacji poszczególnych sekcji  został podzielony na kilka osobnych obiektów działających w sposób niezależny. Dzięki temu możliwe jest ponowne jego wykorzystanie w przypadku implementacji różnych rodzajów zapytań.

\subsection{Struktura}

Głównym obiektem zajmującym się serializacją jest \texttt{CypherSerializer}. Jego zadaniem jest obsługa wszystkich rodzajów zapytań i delegowanie serializacji do odpowiednich klas odpowiadających za dany typ.

Jedną z takich klas jest \texttt{SelectSerializer}, która odpowiada za serializację zapytań typu Select służących do wydobywania danych z bazy. Realizuje ona swoje zadanie z wykorzystaniem obiektów odpowiedzialnych za poszczególne sekcje zapytań takie jak: \texttt{StartSerializer}, \texttt{MatchSerializer}, \texttt{ReturnSerializer}, \texttt{WhereSerializer}.

Aby wygenerowane sekcje były spójne pod względem używanych nazw zmiennych wykorzystywany jest obiekt implementujący interfejs \texttt{NameResolver}. Jego jedyną odpowiedzialnością jest przydzielanie nazw obiektom typu \texttt{Nod}e (wszystkie klasy dziedziczące po \texttt{DomainObject} dziedziczą również po \texttt{Node}). Domyślna implementacja którą jest \texttt{BasicNameResolve}r przydziela nazwy według następującej konwencji. Węzłom pojawiających się w zapytaniu o określonym wewnętrznym identyfikatorze przydzielona nazwa to wartość identyfikatora z prefixem ,,id\_", pozostałym węzłom przydzielany jest kolejny wolny numer (zaczynając od 1) z prefixem ,,n\_". Przykładowe nazwy to np. ,,id\_10" przydzielona dla węzła o identyfkatorze równym 10 oraz ,,n\_2" która może być przydzielona dowolnemu anonimowemu wierzchołkowi. Oczywiście głównym wymogiem klasy implementującej ten interfejs jest by dla danego węzła zawsze zwracana była ta sama nazwa, tylko w ten sposób możliwe jest zachowanie spójności nazw.

\section{Zwracanie wyników}

Istotnym zadaniem narzędzia miało być ukrycie wewnętrznych mechanizmów bazy danych i danie klientowi złudzenia pracy wyłącznie z klasami które sam zdefiniował. By osiągnąć ten cel na poziomie wykonywania zapytań zwracane dane muszą być przetransformowane do klas domenowych. Zadanie zostało zrealizowane z wykorzystaniem prostego ,,mappera" obiektowego polegającego na mechanizmie refleksji.

\subsection{Refleksja w Scali}

Język Scala od wersji 2.10 udostępnia mechanizm refleksji dedykowany do tego języka. We wcześniejszych wersjach refleksja mogła być realizowana wyłącznie przy pomocy API udostępnianego razem z językiem Java. Refleksja pozwala na odczytywanie informacji o dowolnej klasie w trakcie działania programu. Informacje jakie można uzyskać to np. zdefiniowane pola, metody czy w szczególności konstruktory. Poza informacją o dostępnych polach istnieje również możliwość ich modyfikacji, wywoływania metod czy tworzenia instancji danego typu. Jest to zatem nieodzowny mechanizm stosowany przy implementacji narzędzi tworzących obiekty w sposób dynamiczny.

Oczywistą wadą refleksji jest dużo mniejsza wydajność niż w przypadku bezpośredniego operowania na klasie.

WYKRES Z PORÓWNANIEM WYDAJNOŚCI REFLEKSJI VS BEZPOŚREDNI DOSTĘP

\subsection{Mapper obiektowy}

Po wykonaniu zapytania baza danych zwraca wyniki w określonym przez siebie formacie. Może to być np. format JSON w przypadku REST--owej implementacji. Oczywiście narzędzia do obsługi bazy neo4j dostarczają natywnych narzędzi do obsługi wyników. Zajmują się one obsługą poszczególnych pól i rozpoznawaniem typu wartości. Stworzone narzędzie również udostępnia tego typu interfejsy mające na celu ujednolicić dostęp do różnych baz grafowych bądź różnych implementacji. Interfejsem opakowującym pojedyńczy wynik zapytania jest \texttt{ResultItem}. Zadaniem implementacji tego interfejsu jest dostarczanie struktury odwzorowania która dla określonej nazwy pola zwraca jego wartość otrzymaną z silnika bazy danych. Jedyną dostępną implementacją jest \texttt{Neo4jResultItem} które zajmuje się tłumaczeniem wyników otrzymanych z serwisu REST.

Silnik obsługujący wybraną bazę grafową powinien implementować interfejs \texttt{ExecutionEngine}. Interfejs ten wymaga by jego implementacja dostarczała metodę \texttt{exec}. Metoda ta powinna dla każdego obsługiwanego przez neodsl zapytania zlecać jego wykonanie oraz zwracać wyniki w postaci kolekcji obiektów typu \texttt{ResultItem}.

Oczywiście \texttt{ResultItem} jest dość ogólnym typem i nie odpowiada strukturze stworzonej przez programistę wykorzystującego narzędzie. Potrzebny jest zatem mechanizm zajmujący się zamianą obiektów typu \texttt{ResultItem} na instancje klas wybranego typu definiowanego przez klienta aplikacji. Zadanie to realizuje \texttt{ObjectMapper}. Domyślna implementacja mappera tj. \texttt{NodeObjectMapper} wykorzystuje wspomniany już mechanizm refleksji. Tworzy on najpierw instancję danej klasy a następnie modyfikuje pola o takiej samej nazwie jak te określone w tablicy haszującej (dostępnej w obiektach typu \texttt{ResultItem}).

Ze względu na problemy wydajnościowe jakich dostarcza mechanizm refleksji został wprowadzony mechanizm pamięci podręcznej dla informacji pozyskanych w sposób dynamiczny.

\chapter{Przykłady wykorzystania}

W tym rozdziale postaram się zaprezentować kompletne przykłady zastosowania neodsl. Pierwszym z nich będzie sieć społecznościowa zawierająca kilka podstawowych relacji spotykanych w serwisach społecznościowych.

\subsection{Sieć społecznościowa}

Sieci społecznościowe koncentrują się wokół osób i relacji między nimi. Potrzeba zatem reprezentacji osób które będą przechowywane w bazie danych. Służyć do tego będzie prosta klasa Person zawierająca jedno pole name odpowiadające imieniu danej osoby. Poza polem opisującym osobę zawierać ona będzie pola określające relacje łączące ją z innymi obiektami naszej sieci społecznościowej. Będą to \texttt{KNOWS} wiążąca znajomych oraz \texttt{WROTE} która zostanie opisana szczegółowo razem z obiektami typu Comment.

Person Snippet

Kolejnym obiektem składowanym w bazie będą komentarze reprezentowane przez klasę Comment. Typową relacją między osobą a komentarzem jest relacja autorstwa określająca kto napisał dany komentarz. Realizowana będzie ona za pomocą krawędzi \texttt{WROTE}. Kolejną akcją dokonywaną na komentarzach jest głosowanie tj. wydanie aprobaty przez daną osobę. Relacja ta nazywa się \texttt{LIKES}.

Comment snippet

\subsection{Zapytania w sieci społecznościowej}

\chapter{Zmiany w Neo4j 2.0 względem 1.x}

Stworzone narzędzie było projektowane z myślą o wersji 1.9.x która w momencie pisania większej części pracy była obowiązującym stabilnym wydaniem. Wersja druga przyniosła znaczące zmiany, które wymagają omówienia (stoją one w sprzeczności z częścią opisanych tu mechanizmów).

Jedną z bardziej istotnych zmian jest tak zwany mechanizm etykietowania który pozwala na grupowanie węzłów. Poza możliwością określenia typu każdego węzła możliwe stało się nakładanie tzw. więzów (ang. Constraints) na określone typy. Pozwala to na definiowanie czegoś w rodzaju schematu bazy danych znanego z baz relacyjnych. Pojawienie się mechanizmu etykiet miało również wpływ na rozszerzenie języka Cypher. Możliwe jest np. wyszukiwanie wzorców z węzłami określonego typu.

Kolejnym mechanizmem który został gruntownie przebudowany jest indeksowanie. W przypadku wydań z serii 1.x narzut związany z obsługą indeksowania był zrzucony na programistę. W dodatku by wykorzystać dany indeks w zapytaniu trzeba było zażądać tego w sposób jawny w sekcji \texttt{START}. Obecnie indeksy przypominają w dużo większym stopniu funkcjonalność znaną z baz relacyjnych. Nie ma potrzeby jawnego określania jaki indeks powinien zostać wykorzystany w zapytaniu, natomiast samo zarządzanie nimi stało się możliwe z poziomu języka Cypher.

Zmiany dotknęły również języka Cypher który jak określają twórcy stał się bardziej deklaratywny. Istotną zmianą jest np. opcjonalność sekcji \texttt{START}. Zapytania nie muszą zawierać jakichkolwiek węzłów początkowych niemniej zalecane jest ograniczanie zbioru węzłów po których odbywać będzie się wyszukiwanie. Pozostałe zmiany miały na celu uproszczenie składni.

\section{Potencjalne funkcjonalności}

\subsection{Aktualizacja danych}

% zakończenie 
\summary
Podsumowanie

% załączniki (opcjonalnie):
\appendix
\chapter{Tytuł załącznika jeden}

Treść załącznika jeden.

% literatura (obowiązkowo):
\bibliographystyle{unsrt}
\bibliography{master-thesis}

% spis tabel (jeżeli jest potrzebny):
\listoftables

% spis rysunków (jeżeli jest potrzebny):
\listoffigures

\oswiadczenie

\end{document}
