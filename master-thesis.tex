\documentclass[brudnopis]{xmgr}

\usepackage{listings}
% "define" Scala
\lstdefinelanguage{scala}{morekeywords={class,object,trait,extends,with,new,if,while,for,def,val,var,this},
otherkeywords={->,=>},
sensitive=true,
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morestring=[b]"}
% Default settings for code listings
\lstset{frame=tb,language=scala,aboveskip=3mm,belowskip=3mm,showstringspaces=false,columns=flexible,basicstyle={\small\ttfamily}}


%\defaultfontfeatures{Scale=MatchLowercase}
%\setmainfont[Numbers=OldStyle,Ligatures=TeX]{Minion Pro}
%\setsansfont[Numbers=OldStyle,Ligatures=TeX]{Myriad Pro}
% for fontspec version < 2.0
\setmainfont[Numbers=OldStyle,Mapping=tex-text]{Minion Pro}
\setsansfont[Numbers=OldStyle,Mapping=tex-text]{Myriad Pro}
%\setmonofont[Scale=0.75]{Monaco}

% Opcjonalnie identyfikator dokumentu 
% drukowany tylko z włączoną opcją 'brudnopis':
\wersja   {wersja wstępna [\ymdtoday]}

\author   {Mateusz Szygenda}
\nralbumu {186\,436}
\email    {mateusz.szygenda@gmail.com}

\title    {Wykorzystanie baz grafowych w języku Scala}
\date     {2014}
\miejsce  {Gdańsk}

\opiekun  {dr Wiesław Pawłowski}

% dodatkowe polecenia
%\renewcommand{\filename}[1]{\texttt{#1}}

\begin{document}

\begin{abstract}
Wstęp
\end{abstract}
\keywords{Scala, neo4j, DSL, języki domenowe, bazy grafowe}

% tytuł i spis treści
\maketitle

%
% wstęp
\introduction

Celem pracy było stworzenie narzędzia dla języka Scala pozwalającego na efektywne wykorzystanie jednej z opisywanych baz grafowych. Język ten został wybrany ze względu na dostępność licznych mechanizmów ułatwiających definiowanie tzw. języków domenowych (DSL). 

\chapter{Bazy grafowe}

\section{Wstęp}

Bazy grafowe charakteryzują się sposobem reprezentacji danych i zależności między nimi. W odróżnieniu od baz relacyjnych gdzie powiązania pomiędzy tabelami realizuje się za pomocą kluczy obcych bazy grafowe pozwalają na zapisywanie całych grafów w których krawędzie są odpowiednio nazwane i służą do identyfikacji relacji między obiektami. Poza odmienną reprezentacją danych również przeszukiwanie bazy odbywa się w inny sposób. Mianowicie zamiast operować na pojęciach typu tabele i klucze, dane wyszukuje się za pomocą wzorców w grafie.

\section{Rodzaje baz grafowych}

\subsection{Bazy z relacyjnym magazynem danych}
Rozróżniamy dwa główne rodzaje baz grafowych. Pierwszym z nich są bazy które jedynie wystawiają interfejs pozwalający operować na grafach które jednak wewewnętrznie przechowują dane z wykorzystaniem baz relacyjnych. Przykładem takiej bazy danych jest np. FlockDB która wykorzystuje bazę MySQL do składowania danych.

\subsection{Bazy natywne}
Drugim rodzajem baz grafowych są natywne bazy grafowe które nie tylko wystawiają interfejs do przeszukiwania grafów ale również wykorzystują strukturę grafów do przechowywania danych. Ma to tę zaletę iż przeszukiwanie takiej bazy może okazać się o wiele wydajniejsze niż odpowiednik przechowywany w bazie relacyjnej. Powodem tego jest lokalność operacji wykonywanych na grafie. W odróżnieniu do baz relacyjnych gdzie by wyszukać dane powiązane pewną relacją wymagane jest wykonanie iloczynu kartezjańskiego na całych zbiorach danych. W przypadku ogromnej liczby rekordów taka operacja może okazać się wielce niewydajna. W przypadku baz grafowych nie ma potrzeby odwiedzania wszystkich danych bowiem poruszamy się tylko w obrębie obiektów w bezpośredni sposób związanych ze sobą krawędziami. Przykładem takiej bazy jest np. Neo4J której została poświęcona znaczna część tej pracy.

\section{Wiodące bazy}

\chapter{Neo4j}

\section{Język Cypher}
Cypher jest językiem zapytań stworzonym specjalnie na potrzeby neo4j pozwalającym w sposób deklaratywny przeszukiwać bazę grafową.

\subsection{Przeszukiwanie grafu}

Najważniejszym rodzajem zapytań jest oczywiście zapytanie służące do wyszukiwania wzorców i wyciągania danych z grafu. Zapytanie takie składa się z trzech podstawowych części.

Sekcja "START" pozwala na wyciągnięcie węzłów startowych od których zacznie się przeszukiwanie grafu. Węzły można wyciągnąć na podstawie jego wewnętrznego identyfiaktora lub z wykorzystaniem przygotowanego wcześniej indeksu.

\lstinputlisting{listings/cypher/start-section.cypher}

Sekcja "MATCH" jest główną częścią zapytania, pozwala ona bowiem określić interesujące nas wzorce w grafie. Część ta jest swego rodzaju odpowiednikiem instrukcji INNER JOIN w języku SQL.

\lstinputlisting{listings/cypher/match-section.cypher}

Ostatnim elementem zapytania jest sekcja "RETURN" pozwalająca zdefiniowanie obcięcia które ma zostać zwrócone jako wynik zapytania.

\lstinputlisting{listings/cypher/return-section.cypher}

Pełne zapytanie wygląda następująco i zwraca ono identyfikatory oraz imona obiektów które są połączone krawędzią o identyfikatorze "KNOWS" z obiektem john oraz będące połączone krawędzią "LIKES" z obiektem o identyfikatorze równym 1. Poruszając się w domenie sieci społecznościowej zapytanie zwraca znajomych użytkownika John którzy polubili komentarz o identyfikatorze 1.

\lstinputlisting{listings/cypher/sample-query.cypher}

\subsection{Modyfikacja danych}

Język Cypher pozwala również na aktualizację danych w grafie. Wyrażenie takie podobnie jak zapytanie służące do wyszukiwania w grafie składa się z kilku sekcji.

Pierwszą z nich ponownie jest sekcja "START" która pozwala na wybranie wezłów początkowych między którymi będziemy wstawiać relacje. Jest ona opcjonalna jeśli zamierzamy operować wyłącznie na nowych obiektach.

\lstinputlisting{listings/cypher/start-section.cypher}

Kolejną sekcją jest "CREATE" której składnia jest podobna do sekcji "MATCH". W przeciwieństwie jednak do MATCH pozwala ona na tworzenie krawędzi w grafie oraz węzłów.

\lstinputlisting{listings/cypher/create-section.cypher}

Ostatnim elementem jest wykorzystana już wcześniej sekcja RETURN która pozwala na wyciągnięcie danych o nowoutworzonych obiektach takich jak ich identyfikatory.

\lstinputlisting{listings/cypher/return-section-2.cypher}

Pełne zapytanie wstawiające do grafu nowy obiekt o polu "name" równym "New Friend" i łączące go z obiektami "john" oraz "comment" wygląda następująco

\lstinputlisting{listings/cypher/sample-create-query.cypher}

\section{Programistyczne sposoby dostępu do neo4j}

\subsection{Embedded mode}

\subsection{REST mode}

\subsection{Zapytania Cypher}

\chapter{Dostęp do baz danych z wykorzystaniem DSL}

\section{Wstęp}

\section{Bazy SQL}

\subsection{Squeryl}

\section{Bazy NoSQL}

\subsection{Mongoid}

\chapter{DSL do baz grafowych}

\section{Definiowanie modelu}

Pierwszym krokiem jaki należy wykonać przed definiowaniem zapytań jest utworzenie modelu (tj. zbioru klas) odpowiadającemu dziedzinie którą przechowujemy w bazie grafowej. Stworzone narzędzie udostępnia mechanizmy pomocnicze które pozwalają na szybkie odwzorowanie encji oraz relacji między nimi.

\subsection{Klasa DomainObject}

Wszystkie klasy domenowe muszą dziedziczyć po generycznej klasie DomainObject która dostarcza narzędziu niezbędnych informacji do działania. Jest to klasa generyczna która wymaga określenia typu klasy którą definiujemy. Informacja ta jest potrzebna w celu nakładania ograniczeń na obiekty które będzie można stosować do poszczególnych relacji.

Definiowana klasa może zawierać pola następujących typów: Int, Byte, Short, Char, Long, Double, Float, String.

\subsection{Relacje}

Oczywiście najistotniejszą informacją w przypadku baz grafowych są relacje czy też krawędzie wychodzące z węzłów danego typu. Należy je zdefiniować jako pola w klasie domenowej. Nie ma oczywiście potrzeby tworzenia obiektów w sposób ręczny gdyż klasa DomainObject udostępnia metody pomocnicze pozwalające na definiowanie relacji. Są to metody  -->, <--, -- które jednocześnie określają kierunek. Metody te są generyczne i pozwalają na określenie typu obiektów pomiędzy którymi zachodzić będzie relacja. Przyjmują one jeden parametr typu String który pozwala na zdefiniowanie nazwy relacji czy też krawędzi.

\subsection{Przykładowy model}

Oto przykładowa klasa domenowa reprezentująca osobę. Zawiera ona pola takie jak name, surname odpowiadające imieniu i nazwisku osoby oraz pola definiujące krawędzie wchodzące i wychodzące z węzłów tego typu. Są to relacje knows która definiuje krawędź wychodzącą do obiektów typu Person oraz wrote która jest relacją skierowaną do naszego obiektu i jest powiązana z obiektem typu Comment.

\lstinputlisting{listings/scala/dsl/sample-model.scala}

\section{Budowanie wzorców}

Zapytania w bazach grafowych skupiają się na wyszukiwaniu określonych wzorców. Z tego powodu główny nacisk w obrębie ekspresywności tworzonego DSLa został położony właśnie na tej części.

Do budowania wzorców wykorzystywana jest klasa PatternBuilder której instancje tworzone są przez metody pomocnicze używane przy definiowaniu klas, są to mianowicie omówione wcześniej metody <--, --, -->. Klasa PatternBuilder definiuje metodę apply której argumentem może być pojedyńczy obiekt typu określonego w wywołaniu metody kierunkowej lub cały wzorzec który zaczyna się od węzła tego typu. Implikuje to iż budowane wzorce będą zawsze podlegać regułom typów określonym klasach domenowych. Niemożliwe jest na przykład utworzenie wzorca person -[:KNOWS]-> comment gdyż zachodzi niezgodność typów (comment nie jest typu Person).

Oto przykładowe złożenie kilku wzorców. Obiekty john, friend, matthew są typu Person podczas gdy wiseComment jest obiektem typu Comment.

\lstinputlisting{listings/scala/dsl/patterns/functional-example-1.scala}

Wynikiem pojedyńczego wyrażenia budującego wzorzec jest obiekt typu Pattern którego najbardziej istotną podklasą jest PatternTriple. Jest to generyczna klasa która składa się z trzech elementów. Pierwszym z nich jest początek wzorca czyli pojedyńczy węzeł od którego zaczyna się wzorzec. Kolejnym elementem jest relacja z określonym kierunkiem która określa jakiego typu obiektu spodziewamy się w dalszej części wzorca. Ostatnim elementem jest obiekt typu PatternWithNode który jest superklasą bardziej specyficznych PatternNode który służy do definiowania pojedyńczych węzłów oraz wspomniana już klasa PatternTriple. PatternTriple pozwala zatem na definiowanie rekurencyjnej struktury wzorca.

\section{Nakładanie warunków na wyniki zapytań}

Jednym z bardziej istotnych mechanizmów przy przeszukiwaniu baz danych jest możliwość nakładania warunków na zwracane wyniki. Założeniem projektu było aby nie było potrzeby wprowadzania nowej składni do budowania wyrażeń typu Boolean innej niż ta dostarczana przez sam język scala. Oczywiście wyrażenia powinny być wykonywane po stronie serwera bazy stąd zwykłe wyrażenia typu boolean które ewaluuje się do prawdy lub fałszu byłyby niewystarczające by można je przenieść do zapytania Cypher. Aby wyciągnąć strukturę wyrażenia logicznego potrzebne jest wykorzystanie mechanizmu makr które pozwala na modyfikacje abstrakcyjnego drzewa składniowego.

\subsection{Makra}

Makra są eksperymentalną funkcjonalnością języka scala wprowadzone w wersji WERSJA. Są one podobnie jak w przypadku makr znanych z języka C wykonywane podczas etapu kompilacji jednak dają o wiele więcej możliwości. Najważniejszą różnicą w stosunku do wspomnianego C jest fakt, że makra języka Scala nie definiują żadnego specyficznego do tego typu zadań mini-języka. Zamiast tego makra mogą być pisane w języku Scala. Co więcej nie ograniczają się one do prostej zamiany tekstu w kodzie programu jak to bywa w przypadku innych języków ale pozwalają na modyfikację drzewa składniowego. Oczywiście jest to dużo bardziej zaawansowany mechanizm i jego właściwe wykorzystanie jest bardziej skomplikowane, niemniej w zamian otrzymujemy bardzo potężny mechanizm.

By zdefiniować makro w kodzie programu należy utworzyć obiekt z metodą która zamiast ciała zawiera słowo kluczowe macro oraz nazwę metody implementującej dane makro.
Metoda implementująca makro powinna mieć dwie listy parametrów. Pierwsza z nich powinna składać się z argumentu typu Context. Druga lista parametrów powinna zawierać tak samo nazwane argumenty jak w przypadku deklaracji makra jednak ich typ powinien być opakowany przez klasę Expr zdefiniowaną w obiekcie Context. Typem zwracanym takiej metody jest obiekt typu Expr zdefiniowany w kontekście obiektu Context.

Oto przykładowa definicja makra

\lstinputlisting{listings/scala/macro-sample.scala}

Wszystkie wywołania metody assert zostaną zamienione podczas procesu kompilacji przez wyrażenie wygenerowane przez metodę assertImpl. 

Obiekt typu Expr zawiera w sobie strukturę wyrażenia ktore reprezentuje. W przypadku parametrów zawiera on drzewo składniowe przed dokonaniem ewaluacji. Dlatego przy wywołaniu metody assert z parametrami (someInt == 5, "someInt is equal to 5"), w metodzie implementującej mamy dostęp do struktury wyrażenia someInt == 5 które możemy dowolnie przetransformować.

\subsection{Przetwarzanie wyrażeń typu Boolean}

Zastosowanie makr w przypadku projektu polega na zamianie wyrażeń typu Boolean na własną strukturę którą będzie można w prosty sposób serializować do języka Cypher. Strukturę tę rozpoczyna cecha Condition której potomkami są takie klasy jak And, Or, Not które odpowiednio reprezentują koniunkcję, alternatywę i zaprzeczenie warunków oraz PropertyComparison która odpowiada porównaniu pól obiektów z dziedziny.

OBRAZEK Z HIERARCHIĄ KLAS

Implementacja:

Transformers
Builders

\section{Serializacja do języka Cypher}

W każdym zapytaniu języka Cypher da się wyszczególnić kilka głównych składowych odpowiadającym odmiennym zadaniom. Przykładem może być chociażby zapytanie do wyszukiwania danych w grafie które składa się z sekcji Start, Match oraz Return. Te same sekcje pojawiają się również w innych rodzajach zapytań (jak chociażby zapytanie służące do aktualizacji danych w grafie może zawierać w sobie sekcję Start). Z tego powodu serializacja poszczególnych sekcji została wyciągnięta do osobnych obiektów realizujących serializację w sposób niezależny. Dzięki temu możliwe jest ponowne wykorzystanie kodu w przypadku implementacji różnych rodzajów zapytań.

\subsection{Struktura}

Głównym obiektem zajmującym się serializacją jest obiekt CypherSerializer. Jego zadaniem jest obsługa wszystkich rodzajów zapytań i delegewanie serializacji do poszczególnych klas serializujących które składają poszczególne sekcje w kompletne zapytanie.

Jedną z takich klas jest SelectSerializer która odpowiada za serializację zapytań typu Select które służą do wydobywania danych z bazy. Realizuje ona swoje zadanie z wykorzystaniem obiektów odpowiedzialnych za poszczególne sekcje zapytań takie jak: StartSerializer, MatchSerializer, ReturnSerializer, WhereSerializer.

Aby wygenerowane sekcje były spójne pod względem używanych nazw zmiennych wykorzystywany jest obiekt implementujący interfejs NameResolver. Jego jedyną odpowiedzialnością jest przydzielanie nazw obiektom typu Node (wszystkie klasy dziedziczące po DomainObject dziedziczą również po Node). Domyślną implementacja którą jest BasicNameResolver przydziela nazwy według następującej konwencji. W przypadku węzłów o określonym identyfikatorze. Przydzielona nazwa to identyfikator z prefixem "id\_", pozostałym węzłom przydzielany jest kolejny wolny numer (zaczynając od 1) z prefixem "n\_". Oczywiście głównym wymogiem klasy implementującej ten interfejs jest by dla danego węzła zawsze zwracana była ta sama nazwa.

\section{Zwracanie wyników}

Istotnym zadaniem narzędzia miało być ukrycie wewnętrznych mechanizmów bazy danych i danie klientowi złudzenia pracy wyłącznie z klasami które sam zdefiniował. By osiągnąć ten cel na poziomie wykonywania zapytań bazodanowych zwracane dane muszą być przetransformowane do klas domenowych. Zadanie zostało zrealizowane z wykorzystaniem prostego "mappera" obiektowego polegającego na mechanizmie refleksji.

\subsection{Refleksja w Scali}

Język scala od wersji 2.10 udostępnia mechanizm refleksji dedykowany do tego języka. We wcześniejszych wersjach refleksja mogła być realizowana wyłącznie przy pomocy API udostępnianego razem z językiem Java. Refleksja pozwala na odczytywanie informacji o dowolnej klasie w trakcie działania programu. Informacje jakie można wyciągnąć to np. zdefiniowane pola, metody czy w szczególności konstruktory. Poza informacją o dostępnych polach istnieje również możliwość na modyfikacje pól, wywoływanie metod czy tworzenie nowych obiektów danego typu. Jest to zatem nieodzowny mechanizm stosowany przy implementacji narzędzi tworzących obiekty w sposób dynamiczny.

Oczywistą wadą refleksji jest dużo mniejsza wydajność niż w przypadku bezpośredniego operowania na klasie.

WYKRES Z PORÓWNANIEM WYDAJNOŚCI REFLEKSJI VS BEZPOŚREDNI DOSTĘP

\subsection{Mapper obiektowy}

Silnik implementujący interfejs DatabaseEngine ma za zadanie zwracać obiekty implementujące intefejs ResultItem. Udostępnia on metody pozwalające na odczytywanie pól oraz obiektów zwróconych jako wynik zapytania w postaci tablicy hashującej. 

Zadaniem Mappera obiektowego jest zamiana obiektu typu ResultItem na instancję klasy wybranego typu. Domyślna implementacja mappera tj. NodeObjectMapper wykorzystuje wspomniany już mechanizm refleksji. Tworzy on najpierw instancję danej klasy a następnie modyfikuje pola o takiej samej nazwie jak te określone w tablicy hashującej.

W swojej bieżącej implementacji nie wykorzystuje on żadnego mechanizmu cache'owania jednak nic nie stoi na przeszkodzie by w przyszłości wprowadzić taką warstwę i przez to podnieść wydajność całego narzędzia.

\section{Potencjalne funkcjonalności}

\subsection{Aktualizacja danych}

% zakończenie 
\summary
Podsumowanie

% załączniki (opcjonalnie):
\appendix
\chapter{Tytuł załącznika jeden}

Treść załącznika jeden.

% literatura (obowiązkowo):
\bibliographystyle{unsrt}
\bibliography{master-thesis}

% spis tabel (jeżeli jest potrzebny):
\listoftables

% spis rysunków (jeżeli jest potrzebny):
\listoffigures

\oswiadczenie

\end{document}
